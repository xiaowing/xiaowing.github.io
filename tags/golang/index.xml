<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>小wing的驿站</title>
    <link>https://xiaowing.github.io/tags/golang/index.xml</link>
    <description>Recent content on 小wing的驿站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>&amp;copy; Licensed under CC BY-NC-SA.</copyright>
    <atom:link href="https://xiaowing.github.io/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>在Ubuntu 16.04上从源码编译安装go1.9.2</title>
      <link>https://xiaowing.github.io/post/20171226_install_golang_fromsrc_ubuntu/</link>
      <pubDate>Fri, 22 Dec 2017 11:37:20 +0800</pubDate>
      
      <guid>https://xiaowing.github.io/post/20171226_install_golang_fromsrc_ubuntu/</guid>
      <description>&lt;p&gt;这两天在虚拟机上新装了一个 &lt;a href=&#34;http://releases.ubuntu.com/16.04/&#34;&gt;Ubuntu Server 16.04LTS&lt;/a&gt;,于是很自然地想安装一个Go语言环境。以往无论在Windows上还是在Linux上都是用的现成的二进制distribute包来安装Go, 但是这次打算尝试用源码来直接编译安装。于是把本次编译安装的一些手顺和注意事项分享在本文中:&lt;/p&gt;



&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;pure-u-1-1&#34;&gt;
    &lt;div style=&#34;padding: 0 .2em&#34;&gt;
      &lt;img
        class=&#34;pure-img-responsive&#34;
        src=&#34;https://xiaowing.github.io/img/post/20171226/ubuntu-go.png&#34;
        alt=&#34;Go on Ubuntu&#34;&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;


&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;编译安装过程&#34;&gt;编译安装过程&lt;/h2&gt;

&lt;p&gt;得益于Go语言团队的强大技术，Go语言的编译安装非常智能化，整个编译安装过程非常惬意。不过，由于Go语言从1.5版本开始就实现了&lt;a href=&#34;http://www.cnblogs.com/lidyan/p/6727184.html&#34;&gt;自举&lt;/a&gt;, 因此对于一个只有gcc编译环境的几乎等同于一张白纸的系统，必须先编译安装一个1.5以前版本的Go语言，之后再用这个低版本去编译1.9.2的Go语言。&lt;/p&gt;

&lt;p&gt;以下安装过程是在以下环境中实施的&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;操作系统: Ubuntu Server 16.04&lt;/li&gt;
&lt;li&gt;CPU架构:  x86-64&lt;/li&gt;
&lt;li&gt;gcc版本:  5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.5)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;使用gcc编译go-1-4&#34;&gt;使用gcc编译Go 1.4&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Go 1.4的编译依赖于glibc，因此首先需要在Ubuntu上确保安装了新版的glibc&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$sudo apt-get install libc-dev
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下载解压 go1.4源码, 并进行编译。由于编译脚本写得非常好，这一步没有什么特别的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$wget -c -t 3  https://storage.googleapis.com/golang/go1.4-bootstrap-20170531.tar.gz
$tar zxvf go1.4-bootstrap-20170531.tar.gz
$cd ~/go/src
$./all.bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;all.bash脚本执行编译后，会对1.4的各个pkg进行回归测试。这里可能会有一点问题，具体会在后文描述。总之，当编译完成后，会在&lt;code&gt;~/go&lt;/code&gt;目录下生成一个&lt;code&gt;bin&lt;/code&gt;目录，里面有生成的可执行文件&lt;code&gt;go&lt;/code&gt;; 且所有go语言的标准库会生成在&lt;code&gt;~/go/pkg/linux_amd64&lt;/code&gt;目录下(我是x86-64的虚拟机，因此目录名是&lt;code&gt;linux_amd64&lt;/code&gt;。该目录名会因操作系统以及体系架构不同而变化)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用Go语言自举时，需要创建GOROOT_BOOTSTRAP环境变量，指向低版本的Go语言环境。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$cd ~/go/
$export GOROOT_BOOTSTRAP=`pwd`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&lt;code&gt;echo&lt;/code&gt;命令查看该环境变量&lt;code&gt;$echo ${GOROOT_BOOTSTRAP}&lt;/code&gt;，确认它指向的是Go1.4的路径即可.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;/home/wing/go&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;使用go-1-4编译-go-1-9-2&#34;&gt;使用Go 1.4编译 Go 1.9.2&lt;/h3&gt;

&lt;p&gt;这样一来，用于自举的低版本的Go语言便已编译安装完毕，接下来就用它编译安装 Go 1.9.2&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载并编译 1.9.2 , 整个过程仍然无比惬意&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$wget -c -t 3 https://github.com/golang/go/archive/go1.9.2.tar.gz
$cd ~
$tar zxvf go-go1.9.2.tar.gz
$cd ~/go-go1.9.2/src
$./all.bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果编译过程没有问题的话，那么标准输出中就会输出类似以下的信息&lt;/p&gt;

&lt;blockquote&gt;
&lt;h2 id=&#34;all-tests-passed&#34;&gt;ALL TESTS PASSED&lt;/h2&gt;

&lt;p&gt;Installed Go for linux/amd64 in /home/wing/go-go1.9.2
Installed commands in /home/wing/go-go1.9.2/bin&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;由于我是让这个Go语言语言环境在整个系统内生效，而不是装在我的个人home目录下，因此我还要做以下事项。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;移至/opt目录下并使安装全局生效&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$cd ~
$sudo mv go-go1.9.2 /opt/.
$sudo vi /etc/profile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;/etc/profile&lt;/code&gt;文件底部增加下述变量导出&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export GOROOT=/opt/go-go1.9.2
export PATH=$GOROOT/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;此时，切换shell会话测试上述安装设置。&lt;/p&gt;

&lt;p&gt;$ go version&lt;/p&gt;

&lt;p&gt;这时理应输出以下信息:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;go version go1.9.2 linux/amd64&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;至此，整个Go 1.9.2的编译安装就圆满达成&lt;/p&gt;

&lt;h2 id=&#34;一点注意事项&#34;&gt;一点注意事项&lt;/h2&gt;

&lt;p&gt;在编译Go 1.4时，&lt;code&gt;all.bash&lt;/code&gt;最后的回归测试中，有可能会在下述测试中出错并进而打印出出错消息, 从而没有打印出预期的&lt;strong&gt;ALL TESTS PASSED&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; dial_test.go  all connections connected; expected some to time out
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过，即使出现上述现象也不是意味着编译出了问题。真的要论“锅”属于谁的话，其实它属于 Go语言团队。 根据&lt;a href=&#34;https://github.com/golang/go/issues/3307&#34;&gt;这个issue&lt;/a&gt;的相关讨论，该现象有大概率会在 64位Linux的 6g环境(即 x84-64 体系的gcc环境)中编译测试稍低版本的Go代码时出现。为了避免这个现象，Go团队也在后续更新中对&lt;code&gt;dial_test.go&lt;/code&gt;这个测试代码进行了改善(按: 感觉就是把超时时长拉长了一点&amp;hellip;)&lt;/p&gt;

&lt;p&gt;-以上-&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[译文]GO语言是面向对象的吗？</title>
      <link>https://xiaowing.github.io/post/20170816_is_go_object_oriented_cn/</link>
      <pubDate>Wed, 16 Aug 2017 21:48:52 +0800</pubDate>
      
      <guid>https://xiaowing.github.io/post/20170816_is_go_object_oriented_cn/</guid>
      <description>&lt;p&gt;周一在微信上收到了&lt;a href=&#34;http://www.weixinyidu.com/a_277786&#34;&gt;Go中国&lt;/a&gt;公众号推送的一篇文章 &lt;a href=&#34;https://flaviocopes.com/golang-is-go-object-oriented/&#34;&gt;Is GO object oriented&lt;/a&gt; ,读完以后感觉观点还是很有意思的，与我的所见有很多相似之处，所以就饶有兴趣地把它翻译成中文，也算是作为&amp;rdquo;友军&amp;rdquo;的一点贡献吧&amp;hellip;&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;go语言是面向对象的吗&#34;&gt;GO语言是面向对象的吗？&lt;/h2&gt;

&lt;p&gt;原题: IS GO OBJECT ORIENTED?&lt;/p&gt;

&lt;p&gt;作者: Flavio Copes&lt;/p&gt;

&lt;p&gt;链接: &lt;a href=&#34;https://flaviocopes.com/golang-is-go-object-oriented/&#34;&gt;https://flaviocopes.com/golang-is-go-object-oriented/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;有时候我会读到文章宣称&amp;rdquo;GO语言是面向对象的语言&amp;rdquo;，有时候我又会读到一篇持相反观点的文章宣称&amp;rdquo;GO语言无法做到面向对象编程因为它根本没有&amp;rsquo;类&amp;rsquo;&amp;ldquo;.&lt;/p&gt;

&lt;p&gt;有鉴于此，我写了这篇文章来阐述这个话题: &lt;strong&gt;GO语言到底是不是面向对象的语言&lt;/strong&gt;？&lt;/p&gt;

&lt;p&gt;如果你习惯了从某种特定编程语言的视角来思考问题，那么在这个话题上，你可能会由于自己所惯于使用的语言不同而得出截然相反的答案。比如说，如果你之前习惯了使用C语言，那么很显然GO语言拥有太多面向对象的特性；但是如果你之前习惯了使用Java，那么GO语言看起来就不那么&amp;rdquo;面向对象&amp;rdquo;了。&lt;/p&gt;

&lt;p&gt;因此关于这个话题，你首先要做的是摒弃其他语言带给你的先入为主的观念并学会用GO语言的思维模式来思考。&lt;/p&gt;

&lt;p&gt;然后我就可以给出我的答案了: YES. GO语言是一门面向对象的语言, 而且是以一种很清爽的方式实现了面向对象.&lt;/p&gt;

&lt;p&gt;在&lt;a href=&#34;https://golang.org/doc/faq#Is_Go_an_object-oriented_language&#34;&gt;GO语言官方文档的FAQ&lt;/a&gt;中也表述过下述内容&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Is Go an object-oriented language?&lt;/p&gt;

&lt;p&gt;Yes and no. Although Go has types and methods and
allows an object-oriented style of programming, there
is no type hierarchy. The concept of “interface” in Go
provides a different approach that we believe is easy
to use and in some ways more general. There are also
ways to embed types in other types to provide something
analogous—but not identical—to subclassing. Moreover,
methods in Go are more general than in C++ or Java:
they can be defined for any sort of data, even built-in
types such as plain, “unboxed” integers. They are not
restricted to structs (classes).
Also, the lack of a type hierarchy makes “objects” in
Go feel much more lightweight than in languages such as
C++ or Java.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;集众家所长&#34;&gt;集众家所长&lt;/h3&gt;

&lt;p&gt;GO语言从&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E8%BF%87%E7%A8%8B%E5%BC%8F%E7%BC%96%E7%A8%8B&#34;&gt;过程式编程语言&lt;/a&gt;, &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B8%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80&#34;&gt;函数式编程语言&lt;/a&gt;以及&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1&#34;&gt;面向对象编程语言&lt;/a&gt;中都汲取了一些概念并将它们组装在一起后，将那些剩余的概念舍弃从而创造了一门极具特性但又十分地道的编程语言。&lt;/p&gt;

&lt;h3 id=&#34;要结构体-不要类&#34;&gt;要结构体,不要类&lt;/h3&gt;

&lt;p&gt;GO语言中并没有传统面向对象编程语言中的&amp;rdquo;类&amp;rdquo;(&lt;code&gt;class&lt;/code&gt;)的概念，取而代之的是使用了&amp;rdquo;结构体&amp;rdquo;(&lt;code&gt;struct&lt;/code&gt;)。但是GO语言的结构体可比C语言中的同名前辈要强大得多。在GO语言中,结构体以及结构体的方法(&lt;code&gt;method&lt;/code&gt;)发挥了与传统意义上的&amp;rdquo;类&amp;rdquo;相同的作用，同时在概念上又清晰分明——结构体只负责管理状态，不管理行为;而结构体的方法则负责定义结构体的行为，比如说允许他们更改状态.&lt;/p&gt;

&lt;h3 id=&#34;封装的奥义&#34;&gt;封装的奥义&lt;/h3&gt;

&lt;p&gt;我认为GO语言中最好的一个特性就是，直接明了地通过字段名, 方法名以及函数名的首字母大写来保证它们的访问可见性为&lt;strong&gt;public&lt;/strong&gt;。其他的那些以小写字母开头的字段等则默认为包(&lt;code&gt;package&lt;/code&gt;)内私有(private)并且无法被导出至包外。这个特性使得开发者们一眼就可以看出来哪些字段/方法/属性是public的，哪些是private的。另外，由于GO语言中没有&lt;strong&gt;继承&lt;/strong&gt;这一概念，所以GO语言中的访问修饰也就根本没有&lt;code&gt;protected&lt;/code&gt;的概念.&lt;/p&gt;

&lt;h3 id=&#34;无继承&#34;&gt;无继承&lt;/h3&gt;

&lt;p&gt;GO语言中没有&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%BB%A7%E6%89%BF_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)&#34;&gt;继承&lt;/a&gt;,这一点在&lt;a href=&#34;https://golang.org/doc/faq#Why_is_there_no_type_inheritance&#34;&gt;GO语言官方文档的FAQ&lt;/a&gt;也有明确说明:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Object-oriented programming, at least in the best-known
languages, involves too much discussion of the
relationships between types, relationships that often
could be derived automatically. Go takes a different
approach.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;用组合代替继承&#34;&gt;用组合代替继承&lt;/h3&gt;

&lt;p&gt;程序设计理念中最广为认知的准则之一即是 &lt;a href=&#34;https://en.wikipedia.org/wiki/Composition_over_inheritance&#34;&gt;用组合代替继承&lt;/a&gt;。这一准则在&lt;a href=&#34;https://en.wikipedia.org/wiki/Design_Patterns&#34;&gt;四人帮&lt;/a&gt;的那本极富盛名的《设计模式》也屡有提及。而在GO语言中，这一准则被发挥得淋漓尽致。&lt;/p&gt;

&lt;p&gt;当我们在定义一个结构体时，我们可以追加类型为另一个结构体的匿名字段。这样一来，我们定义的这个结构体也就同时拥有了另一个结构体的所有字段以及方法。这种技法被称之为&lt;strong&gt;Struct Embedding&lt;/strong&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

type Dog struct {
	Animal
}
type Animal struct {
	Age int
}

func (a *Animal) Move() {
	fmt.Println(&amp;quot;Animal moved&amp;quot;)
}
func (a *Animal) SayAge() {
	fmt.Printf(&amp;quot;Animal age: %d\n&amp;quot;, a.Age)
}
func main() {
	d := Dog{}
	d.Age = 3
	d.Move()
	d.SayAge()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://play.golang.org/p/IxMoeByWp5&#34;&gt;执行结果&lt;/a&gt; (需要科学上网)&lt;/p&gt;

&lt;h3 id=&#34;接口&#34;&gt;接口&lt;/h3&gt;

&lt;p&gt;忘记Java或PHP风格的接口概念吧！GO语言中的接口是截然不同的，而其中最关键的一个特性即是: &lt;strong&gt;接口是隐式实现的&lt;/strong&gt;——不需要在定义类型时去显式声明一下类型实现了哪些接口。&lt;/p&gt;

&lt;p&gt;还是摘抄自&lt;a href=&#34;https://golang.org/doc/faq#Why_is_there_no_type_inheritance&#34;&gt;GO语言官方文档的FAQ&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Rather than requiring the programmer to declare ahead
of time that two types are related, in Go a type
automatically satisfies any interface that specifies a
subset of its methods.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通常，接口的定义都很短，甚至有可能至包含一个方法声明。在地道的GO语言实践中，你不应该看到一个接口拥有长长的方法列表。&lt;/p&gt;

&lt;p&gt;借助这样的接口就可以很优雅地实现&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%9E%8B_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)&#34;&gt;多态&lt;/a&gt;: 一个方法如果接受某一个接口，那么就意味着这个方法接受了任何实现了该接口的对象.&lt;/p&gt;

&lt;h3 id=&#34;方法&#34;&gt;方法&lt;/h3&gt;

&lt;p&gt;GO语言中的类型往往都拥有方法，但是这些方法的定义是独立于类型定义而存在的。GO语言在语法层面通过一个类似Javascript中prototype方法的特性来实现了这种定义的独立性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Person(first, last) {
    this.firstName = first;
    this.lastName = last;
}
Person.prototype.name = function() {
    return this.firstName + &amp;quot; &amp;quot; + this.lastName;
};
p = new Person(&amp;quot;Flavio&amp;quot;, &amp;quot;Copes&amp;quot;)
p.name() // Flavio Copes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在GO语言中，代码应该写成这样:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)
type Person struct {
	firstName string
	lastName  string
}
func (p Person) name() string {
	return p.firstName + &amp;quot; &amp;quot; + p.lastName
}
func main() {
	p := Person{&amp;quot;Flavio&amp;quot;, &amp;quot;Copes&amp;quot;}
	fmt.Println(p.name())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;关联方法与类型&#34;&gt;关联方法与类型&lt;/h3&gt;

&lt;p&gt;方法可以被关联至任何类型,甚至是&amp;rdquo;曲线救国&amp;rdquo;式地关联到GO语言中的基础类型。由于方法只能被关联至在同一个包中定义的类型,所以我们无法直接&amp;rdquo;扩展&amp;rdquo;基础类型。但事实上，我们可以通过对基础数据类型定义别名从而达到扩展的目的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

type Amount int

func (a *Amount) Add(add Amount) {
	*a += add
}

func main() {
	var a Amount
	a = 1
	a.Add(2)
	fmt.Println(a)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://play.golang.org/p/ONlUmue1jA&#34;&gt;显示结果&lt;/a&gt; (需要科学上网)&lt;/p&gt;

&lt;h3 id=&#34;函数&#34;&gt;函数&lt;/h3&gt;

&lt;p&gt;让我们回想一下传统的面向对象编程语言吧，比如Java。想想看你曾经定义过多少次包含的全是static方法的名为&amp;rdquo;Utils&amp;rdquo;的类?&lt;/p&gt;

&lt;p&gt;这样的现象来源与传统的面向对象变成语言中的一个观念: &lt;strong&gt;一切皆是对象&lt;/strong&gt;，因此函数定义必须放在一个类里面。所幸的是，这种现象不会发生在GO语言中，因为GO语言有真正的&amp;rdquo;函数&amp;rdquo;这一概念。在真实世界中，并非所有事物都必须是一个对象。&amp;rdquo;类&amp;rdquo;和&amp;rdquo;对象&amp;rdquo;的概念很有用，但也不能到处都用。&lt;/p&gt;

&lt;p&gt;在GO语言中，并非所有东西都是对象(若严格从技术角度而言，GO语言没有东西是对象。但通常人们会将一个类型的实例或者变量称之为&amp;rdquo;对象&amp;rdquo;),方法仅仅是指那些被关联至某一类型的函数。但GO语言同时又允许函数脱离于对象而独立存在,就如同C语言的函数一样。&lt;/p&gt;

&lt;p&gt;所以，GO语言既允许方法存在，也允许函数存在。而且，函数是第一优先的(函数类型可用作定义结构体字段,函数可作为参数传递至其他函数，函数也可作为返回值被函数或方法返回)。&lt;/p&gt;

&lt;h3 id=&#34;大道至简&#34;&gt;大道至简&lt;/h3&gt;

&lt;p&gt;综上所述，GO语言对于面向对象的实现非常灵活且直接。不用再纠结于类和继承，你可以减少对源码模板文件的依赖，而且不用再一点一点地推敲类与类之间的理想层级结构，从此你只需根据需求自由地对类型进行组合或拆解即可。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>主线程等待子线程结束的各语言实现</title>
      <link>https://xiaowing.github.io/post/20170805_main_thread_sync_with_others/</link>
      <pubDate>Sat, 05 Aug 2017 22:18:06 +0800</pubDate>
      
      <guid>https://xiaowing.github.io/post/20170805_main_thread_sync_with_others/</guid>
      <description>&lt;p&gt;在涉及到并发编程的情况下，经常性地会碰到一种场景:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;由一个线程开启了多个线程并发执行多个任务，之后由该线程(so called &amp;ldquo;主线程&amp;rdquo;)等待多个线程都结束后汇总结果.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这种场景下，主线程在其创建的子线程执行期间内需要阻塞，直到其他子线程都执行完毕。由于这类场景已经在不同语言的开发中遇到多次，所以汇总一下这些语言的常用实现方法，以后查起来也方便~&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;C语言实现
C语言在操作多线程方便由于缺乏一个统一的标准库，所以在Linux和Windows上各有各的实现方法:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Linux版实现&lt;/p&gt;

&lt;p&gt;在Linux上的实现，主要是基于POSIX thread库进行实现，实例代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;pthread.h&amp;gt;

int main(void) {
    int i;
    pthread_t threads[THREAD_NUM];

    pthread_setconcurrency(THREAD_NUM);

    for (i = 0; i &amp;lt; THREAD_NUM; i++){
        /* 将需要执行的job的函数地址func传入新建的子线程 */
        pthread_create(&amp;amp;threads[i], NULL, func, NULL);
    }

    for(i = 0; i &amp;lt; THREAD_NUM; i++){
        pthread_join(handles[i], NULL);
    }

    /* 后续的处理逻辑略... */
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Windows版实现&lt;/p&gt;

&lt;p&gt;在Windows版上的实现中，主要是基于Windows API实现。由于Windows本身就和Linux就是风格迥异，因此在阻塞主线程的API设计上，也是略有不同：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;Windows.h&amp;gt;

int main(void) {
    int i;
    HANDLE handles[THREAD_NUM];

    for (i = 0; i &amp;lt; THREAD_NUM; i++){
        /* 将需要执行的job的函数地址func传入新建的子线程 */
        handles[i] = CreateThread(NULL, 0, func, NULL, 0, NULL);
    }

    WaitForMultipleObjects(THREAD_NUM, handles, TRUE, INFINITE);

    /* 后续的处理逻辑略... */
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是，Windows API的&lt;code&gt;WaitForMultipleObjects()&lt;/code&gt;其实不仅仅是为多线程场景服务的，它可以用与多种内核句柄，如&lt;code&gt;Event&lt;/code&gt;，&lt;code&gt;Mutex&lt;/code&gt;，&lt;code&gt;Process&lt;/code&gt;，&lt;code&gt;Thread&lt;/code&gt;，&lt;code&gt;Semaphore&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Python3的实现&lt;/p&gt;

&lt;p&gt;Python3的实现形式与C语言的Linux版类似: 当子线程仍活着的时候，则通过类似Join()方法之类的API来阻塞当前的主线程。代码示例如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from threading import Thread

if __name__ == &#39;__main__&#39;:
    thread_list = []

    for x range (0, THREAD_NUM):
        # 将需要执行的job的函数和参数传入新建的子线程
        t = Thread(target=job_func, args=(job_args,))
        t.start()
        thread_list.append(t)
        
    for element in thread_list:
        if element.is_alive():
            element.join()    # 通过join方法阻塞主线程
    else:
        # 后续的处理逻辑略...
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Golang的实现&lt;/p&gt;

&lt;p&gt;由于Golang的语言特色，并发通过goroutine来实现。通常情况下，各个goroutine根本不需要知道彼此的存在。因此对于这个场景的实现方式，与之前的那些语言都有所不同.代码示例如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main
    
import (
    &amp;quot;sync&amp;quot;
)

func main() {
    var wait sync.WaitGroup
    wait.Add(ROUTINE_NUM)

    for i := 0; i &amp;lt; ROUTINE_NUM; i++ {
        go func() {
            defer wait.Done()

            //Goroutine所要执行的Job逻辑略...
        }()
    }
    wait.Wait()

    // 后续的处理逻辑略...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在之前的语言中，主线程在起了多个子线程后，不管用什么API阻塞，主线程或多或少还需要关注一下子线程(句柄等)，但是在Golang中，主协程不需要关注各个携程。主协程等待其他协程的这个场景，完全基于Workgroup就可以简单实现。&lt;/p&gt;

&lt;p&gt;真不愧是一门面向并发的语言:)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后需要说明的是，虽然本文描述的这个场景叫做&amp;rdquo;主线程等待子线程&amp;rdquo;。但实际上，无论是线程模型还是协程模型，线程与线程之间(协程与协程之间)都是平等的。毕竟只有在多进程模型下，被fork出的子进程会继承父进程的大部分数据(如打开的文件描述符)，完全相当于父进程的副本的形式。而这样的关系在线程模型(或协程模型)中并不存在，此处的说法完全只是遵循某种不成文的惯例，算是&amp;rdquo;&lt;strong&gt;阀值&lt;/strong&gt;&amp;ldquo;之于&amp;rdquo;&lt;strong&gt;阈值&lt;/strong&gt;&amp;ldquo;这样的错误吧。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C语言程序通过函数指针调用Go函数的方法</title>
      <link>https://xiaowing.github.io/post/howto_call_a_go_func_via_funcpoint_from_cside/</link>
      <pubDate>Sun, 30 Jul 2017 16:16:03 +0800</pubDate>
      
      <guid>https://xiaowing.github.io/post/howto_call_a_go_func_via_funcpoint_from_cside/</guid>
      <description>&lt;p&gt;在github上关于cgo的wiki中，有一&lt;a href=&#34;https://github.com/golang/go/wiki/cgo#function-pointer-callbacks&#34;&gt;章节&lt;/a&gt;专门介绍了如何利用cgo技术通过函数指针调用Golang的函数实现. 不过，仔细观察这个章节的代码示例可以发现，它所要解决的其实是以下的场景:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在Golang中想要调用一个已有的C语言函数，但是该C语言函数要求一个函数指针作为参数时应该怎么办？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果将这个场景稍微改变一下，改成以下场景，对应的解法又该是什么？&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在一个C语言实现的已有系统中，对于一个要求函数指针的函数，如何传入一个Golang实现的回调函数以实现“用Golang扩展C语言系统”的目的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我基于wiki中已有的代码简单探索了一下方法，结果分享如下：&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;试验代码的准备&#34;&gt;试验代码的准备&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先，需要一个声明了函数指针类型的头文件(也就是C语言和Golang的接口)。这里流用了上述wiki中的示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* clib.h */

#ifndef CLIBRARY_H
#define CLIBRARY_H
typedef int (*callback_fcn)(int);
#endif
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;接下来是C语言程序中调用上述函数指针的入口函数.这个文件也是从wiki中流用的.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* clib.c */
#include &amp;lt;stdio.h&amp;gt;
#include &amp;quot;clib.h&amp;quot;

void some_c_func(callback_fcn callback)
{
    int arg = 2;
    printf(&amp;quot;C.some_c_func(): calling callback with arg = %d\n&amp;quot;, arg);
    int response = callback(2);
    printf(&amp;quot;C.some_c_func(): callback responded with %d\n&amp;quot;, response);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个程序中，没有定义callback_fcn这个函数指针的具体实现。这个实现将交给下面的Golang进行&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在Golang中实现回调函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* goprog.go */
package main        /* 包名必须是main */

/*
#cgo CFLAGS: -I {clib.h的路径(目录)}

#include &amp;quot;clib.h&amp;quot;

int callOnMeGo_cgo(int in); // Forward declaration.
*/
import &amp;quot;C&amp;quot;

import &amp;quot;fmt&amp;quot;

//export callOnMeGo
func callOnMeGo(in int) int {
    fmt.Printf(&amp;quot;Go.callOnMeGo(): called with arg = %d\n&amp;quot;, in)
    return in + 1
}

func main() {}        /* 必须定义一个空的main函数 */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个文件基于Wiki中的示例稍微改了一点，把main函数的实现给去掉了，但保留了一个空的main函数。 此外，不论这个文件在哪里创建，它的package被定义为main。相关的理由如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;cgo在将go源代码编译成shared-library的过程中，只会将package声明为main的源代码纳入编译，其余的文件都会被忽略&lt;/li&gt;
&lt;li&gt;由于参与编译的源代码的package都为main，根据Golang编译器的规则，则必须有一个main()函数，否则编译不过&lt;/li&gt;
&lt;li&gt;根据第2点，如果参与编译的源码中有超过一个main函数，编译器也会报错。
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意: 这里有一个坑：如果将带main函数的.c文件和这些go文件放在一起，然后启动golang编译器编译器编译，也会报错，说main函数数量过多。不知golang编译器为什么要去识别C语言的main函数&amp;hellip;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;这样一来，回调函数的实现本体就已经完成了。但是如果仅仅如此，是无法实现C语言调用这个函数的，这是因为两种语言的类型不一致，因此实际上上述回调函数的接口与函数指针的声明仍然不一样，所以需要一个&lt;strong&gt;Adapter&lt;/strong&gt;。在cgo中，这样的&lt;strong&gt;Adapter&lt;/strong&gt;被称为&amp;rdquo;&lt;code&gt;Gateway Function&lt;/code&gt;&amp;rdquo;. 直接搬用Wiki中的代码即可：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* cfuncs.go */
package main

/*

#include &amp;lt;stdio.h&amp;gt;

// The gateway function
int callOnMeGo_cgo(int in)
{
    printf(&amp;quot;C.callOnMeGo_cgo(): called with arg = %d\n&amp;quot;, in);
    int callOnMeGo(int);
    return callOnMeGo(in);
}
*/
import &amp;quot;C&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有意思的是，这个Gateway Function实际上是一个实现在go源码注释中的C语言函数，它的声明与函数指针一致。但是它实际封装的却又是一个golang函数.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;构建过程&#34;&gt;构建过程&lt;/h2&gt;

&lt;p&gt;到这时为止，所需的代码就算是写完了，接下来需要把程序构建并运行起来：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;用golang编译器构建共享库:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$go build -buildmode=c-shared -o libgoprog.so {所有参与编译的go源码}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;值得注意的是，&lt;code&gt;-buildmode=c-shared&lt;/code&gt; 是直到&lt;strong&gt;golang1.5&lt;/strong&gt;开始才有的选项，且该选项到目前为止(golang1.8)只支持linux平台，&lt;strong&gt;不支持windows和Mac OS&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;编译成功后，会生成两个文件： 一个是库文件(&lt;code&gt;libgoprog.so&lt;/code&gt;), 另一个是该库文件对应的头文件(&lt;code&gt;libgoprog.h&lt;/code&gt;).这个头文件的片段如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* libgoprog.h */

#include &amp;quot;clib.h&amp;quot;
int callOnMeGo_cgo(int in);  /* &amp;lt;- 在go源码中定义的Gateway Function */

...(中略)...

extern GoInt callOnMeGo(GoInt p0);   
...(下略)...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时如果用&lt;code&gt;file&lt;/code&gt;命令看一下生成的.so文件，应该是类似以下的结果：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;libgoprog.so: ELF 64-bit LSB  shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=f49bbe5d2d38c184574b65ed11f55e84c1ad19e3, not stripped&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;同时，如果用&lt;code&gt;nm&lt;/code&gt;查看这个.so文件的导出符号，就可以看到callOnMeGo和callOnMeGo_cgo这两个符号了&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;由于上一步骤生成了这个头文件，所以此处还需要修改一下之前的 clib.c 文件，把这个头文件给 #include 进去，从而就可在clib.c中看见那个Gateway Function的声明了，而且此时就可以为clib.c文件补上 main() 函数的实现了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* clib.c 完整版 */

#include &amp;lt;stdio.h&amp;gt;
#include &amp;quot;clib.h&amp;quot;
#include &amp;quot;libgoprog.h&amp;quot;    /* 追加头文件引用 */

void some_c_func(callback_fcn callback)
{
    int arg = 2;
    printf(&amp;quot;C.some_c_func(): calling callback with arg = %d\n&amp;quot;, arg);
    int response = callback(2);
    printf(&amp;quot;C.some_c_func(): callback responded with %d\n&amp;quot;, response);
}

int main(void) {        /* 追加main()函数实现 */
    some_c_func(callOnMeGo_cgo);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编译这个C程序&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;$gcc clib.c -I{clib.h的目录路径} -I{生成的libgoprog.h的目录路径} -L{libgoprog.so的目录路径} -lgoprog -o clibmain
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一切正常的话，就可以正常生成可执行文件clibmain了。之后再将先前生成的libgoprog.so 放置到链接器可找到的路径下，执行该程序就可得到下述结果了:&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;



&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;pure-u-1-1&#34;&gt;
    &lt;div style=&#34;padding: 0 .2em&#34;&gt;
      &lt;img
        class=&#34;pure-img-responsive&#34;
        src=&#34;https://xiaowing.github.io/img/post/20170730/c-calls-go-output.jpg&#34;
        alt=&#34;通过函数指针调用golang函数的输出&#34;&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;


&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;综上，使用golang自带的cgo技术，可以方便地打通C语言和Golang语言。但目前，Go语言编译动态库还只能在Linux平台上实现，需要注意。&lt;/p&gt;

&lt;p&gt;另外，考虑到两种语言在数据类型上还是存在较多差异(事实上，编译生成共享库时附带生成的头文件中就定义了大量golang类型到C语言的映射)，因此，如果真的要编写程序在C语言中调用Go，其实有相当一部分工作量应该会花在数据类型转换上。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>一件如故的Go语言</title>
      <link>https://xiaowing.github.io/post/why_i_love_the_go_programming_language/</link>
      <pubDate>Sun, 30 Jul 2017 14:17:37 +0800</pubDate>
      
      <guid>https://xiaowing.github.io/post/why_i_love_the_go_programming_language/</guid>
      <description>&lt;p&gt;从去年接触Go语言(以后简称&amp;rdquo;Golang&amp;rdquo;)到现在，已经有1年的时间了。感觉随着使用经验的积累，越发地喜爱这么编程语言。作为一个以C, C#语言出道，并自学了Java, Python, Golang的无证程序员，使用 了一段时间Go语言后，最明显的感觉就是：“这正式我所期盼的语言”。特别是写多了C语言代码，虽然感叹于C语言在语言上的简洁与性能上的高效，但是对于现实中C语言在开发方面的低效也总是吐槽不断。遭遇了Go语言之后，认为这门语言是C语言的最好传人(不要提C++)。&lt;/p&gt;



&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;pure-u-1-1&#34;&gt;
    &lt;div style=&#34;padding: 0 .2em&#34;&gt;
      &lt;img
        class=&#34;pure-img-responsive&#34;
        src=&#34;https://xiaowing.github.io/img/post/golang-gopher-100.jpg&#34;
        alt=&#34;Gopher&#34;&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;


&lt;p&gt;以下分享一些我认为Golang做的比较值得推崇的地方：&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Golang是直接编译成本地机器码，这就决定了其二进制是无法跨平台的。但是得益于Golang社区在各个平台上开发的编译器都很给力，而且提供了共通且强大的标准库，使得对于Go语言的开发者而言事实上不需要去太关注跨平台的问题(当然，可能会需要在特定平台上额外加一些分支代码以做优化或处理平台本身的差异)也能保证Golang程序拥有不弱于C的运行性能。这一点相比较C语言开发而言，实在时友善了太多：

&lt;ul&gt;
&lt;li&gt;C语言为了兼容不通平台，往往会用到条件编译，如果没有实现好好设计跨平台的问题，代码中就会充斥着一大堆#ifdef ，导致可读性极差；但如果每个C语言项目都要去专门为跨平台好好设计一番，却又会导致项目的额外投入以及关注点扩散。总之实际开发中的效率不会高&lt;/li&gt;
&lt;li&gt;C语言标准库功能太薄弱，所以各个平台往往为了相似的基础功能折腾出一堆不通的基础库。尽管后来有了Posix规范，但毕竟这只是个弱约束。比如说巨硬的WinAPI，完全看不到一点Posix的影子，你也不能拿它怎么样。所以还是导致C语言项目会专门为了跨平台投入过多的人力和成本。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Golang提供了一个内存管理机制(含GC)。这相对于原先的C语言开发而言，可算是大大地解放生产力了：

&lt;ul&gt;
&lt;li&gt;C语言开发需要自行管理内存的分配与释放(其实说法不确切，标准库的malloc函数群其实是实现了一个内存池以避免触发过多系统调用)，每一个C语言工程师肯定都与诸如内存泄露，重复释放，野指针误操作等问题搏斗过，费时费力。&lt;/li&gt;
&lt;li&gt;不少C语言开发项目的工作量都耗费在了为本项目进行的内存管理的设计与开发上了。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;得益于Golang自带内存管理功能，因此Golang提供了源生的string类型，而且颇为独特地将内置字符串的文字编码定义为UTF-8(Java，C#，Python3的内置字符串类型的文字编码都是UTF-16)。这样的设计带来了一些显而易见的好处:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;相较于C语言开发，用Golang开发时终于不用自己去处理 &lt;code&gt;char *&lt;/code&gt;指针了。我们学C语言，道行尚浅往往会有个错觉，以为字符串一定会以&amp;rsquo;\0&amp;rsquo;结尾。这个理解得不深刻，往往会给我们带来一些麻烦。之后被坑得多了，才终于反应过来——NM就是一个字节数组。这个积累过程往往需要一些时间，归根结底还是没有一个专门的字符串类型(但事实上，通常情况下，我们要处理的数据有大多数都是字符串)。所以Golang提供了一个string类型也是理所当然。Golang对于String的实现也很符合实际，就是一个形如下方的结构体。这也导致了为什么在Golang中对string进行遍历时是基于字节而非字符来遍历的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct String
{
    byte*   str;
    intgo   len;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;与Java，C#，Python不同的是，Golang的字符串类型的文字编码是UTF8。我个人认为这是考虑到了互联网的需求。毕竟UTF16的每一个字符要占用两个字节。而考虑实际的情况，不管你是传一个html，还是传一个json报文，终究大部分字符还是那些在标准ASCII码范围内的字符。而且，假设数据真的按UTF16来传，还会牵扯到Big-endian和Little-endian的问题。而按UTF8编码传递则没有此问题。可以说，选择UTF-16的话，只对于语言本身的实现时可以减轻不少负担。所幸，Golang的设计者们也认识到了这一点。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Golang中对于函数库的构建，都是统一编译为静态库。当调用者要使用时是要在编译阶段就将函数库静态链接进来的。这个特性有时不被开发者理解，甚至有人认为是一种倒退。但如果我们仔细梳理一下就会发现用静态库时经过深思熟虑的选择：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;部署方便，不会再存在Dependency Hell的问题（代价是程序加载时会多吃点内存）。Linux 系的程序经常陷入Dependency Hell的困扰；而Windows程序虽然稍微好一点，但它是因为在Windows系程序的最佳实践，通常时把所依赖的动态库一并发布。保证程序和程序之间井水不犯河水，以希图消除Dependency Hell的问题，但结果就是，把动态库(又称“共享库”)技术中的“共享”给丢了。&lt;/li&gt;
&lt;li&gt;另一方面，从程序开发技术的历史来看，静态链接技术的诞生是早于动态链接技术的。甚至应该说，动态链接技术更像是静态链接当年面对贫瘠的内存与磁盘资源所做出的一个妥协性质的进化。既然在21世纪的今天，连PC机的内存与磁盘都已经不再是问题的情况下，作为一门新语言，选择在技术上返朴归真也是情有可原。更何况，如果从纯性能角度考量，静态库是要优于动态库的。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Golang还是一门没有实现“类”这个概念但却仍旧可以让你进行面向对象编程的语言。这样一来，概念就非常清晰了，和当年C语言的“简约”的思想一脉相承：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;从80时代开始，“面向对象”思想就开始广为流传。它作为程序设计的一种方法论本身没有错，但问题是如果一个语言非要以支持不支持类这个概念来一刀切地区分自己是不是一个支持面向对象的语言。这就有点走火入魔了。在这方面，Java和C#是这类语言的极端代表，于是写一个入口函数main函数，都得先定义一个类，这实在是让人哭笑不得。更不用说Java和C#在后面的发展中被自己的“必须得有类”的这个概念所坑，先后都引入了一个称之为“静态类”的不伦不类的东西。万幸，Golang吸取了这个教训，没有搞出“类”这个东西。&lt;/li&gt;
&lt;li&gt;面向对象的思想其实是与语言无关，事实上，就算是用C语言也仍然可以在“面向对象”思想的主导下实施开发，从一些优秀开源代码(如PostgreSQL)来看，用C语言也照样可以写出面向对象的风格。与C语言类似，Golang对于“面向对象”思想的三个基本特征也是予以了一定的支持，实现了对“面向对象”技术的“取取其精华去其糟粕”：

&lt;ul&gt;
&lt;li&gt;封装 —— 通过golang的package机制的数据/函数公开规则予以实现&lt;/li&gt;
&lt;li&gt;继承 —— 通过Interface机制在思想上进行了实现（尽管Golang的接口时通过“组合”(Composite)来实现的），但是在语言特性层面却没有专门的“继承”功能&lt;/li&gt;
&lt;li&gt;多态 —— 语言特性上没有专门的“多态”，甚至连函数的参数化多态(Overloading)也不支持&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Golang保留了指针，有助于帮助开发者厘清数据之间关系的真实情况：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在函数参数方面，Java和C#算是捣糨糊的高手。Java为了所谓的“值传递”与“引用传递”，凭空捣鼓出了“原始类型”和“引用类型”这两个概念；C#则更进一步，在彻底地把所有类型都变成“类”了之后，捣鼓出了“值类型”和“引用类型”这两个概念。当然，正式因为这两个高级语言对开发者屏蔽了“地址”(也就是“指针”)这个概念后不得不生造出的概念。其实事情本可以很简单——只要一门语言中的函数调用的参数传递还是基于栈模型(有没有其他模型我不知道&amp;hellip;)，那么参数传递一定是把你希望传递的数据给拷贝走一份后再进行操作。因此，如果你想在一个函数中改变一个已有的数据结构实例中的属性（成员变量），那么你就老老实实地把这个实例的地址(指针)给传过去。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Golang通过&amp;rdquo;接受者&amp;rdquo;(receiver)这个概念，可以把一个函数变成某个数据类型的“方法”，从而相较于C语言的代码更易理解，易维护：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;正如“类”不是必须的，“方法”其实也不是必须的。receiver这个特性更像是一个语法糖。只是，有了方法之后从代码层面就可以更明显地看出一个操作和一个数据结构之间时强联系还是弱联系。也正因为有了这个特性，所以Golang的“面向对象”的特征就“更加明显”了。&lt;/li&gt;
&lt;li&gt;写C语言代码时，通常为了在代码中体现一个函数与一个数据结构是强联系，函数是数据结构的“方法”，所以通常会选择把这个数据结构的参数放在函数参数列表的第一个。也许Golang设计团队对于这个最佳实践也是深有感触之后才下决心做了“receiver”这个特性。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Golang中的&lt;code&gt;defer&lt;/code&gt;机制可以有效增强代码的健壮性。用其他语言写代码，一旦涉及到数据库连接，文件句柄等资源操作时要格外小心，生怕有什么分支忘记关闭这些资源。有了defer机制，打可以在打开资源语句的下一条语句就用defer把关闭资源的操作塞入栈中，确保关闭操作一定被执行。并且有效地减少了函数中各种退出分支中冗长的关闭资源代码。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;至于Golang语言中以go关键字和chan关键字体现出的 “协程”和 “信道”这两个并发程序开发中的利器，已经有太多人盛赞过了，这里就不在赘述。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;从以上可以看出，其实Golang语言的一些特性是源于C语言，但又更好地解决了C语言开发中的一些通点，使得在不太牺牲性能的前提下提升开发效率。Golang团队不愧是有C语言的发明者之一的Ken Tompson参与，所以能够有的放矢地去改善C语言在新时代形势下的一些课题。&lt;/p&gt;

&lt;p&gt;然而，Golang中终究还是有一些我个人觉得比较遗憾的地方，也记录在此吧:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;以 &lt;code&gt;${变量名} 类型&lt;/code&gt; 这样类型在后的声明方式终究还是太小众了，特别是有时候定义函数时，写着写着就把参数列表写成了 类型 ${参数名} 这样的传统方式了。然后非要等编译出错才能反应过来(有时候还未必能反应过来)。 类型在后的声明方式，想了半天似乎也就只有&lt;strong&gt;SQL&lt;/strong&gt;是这样的。&lt;/li&gt;
&lt;li&gt;与C语言一样，Golang中无法定义参数类型不同，函数名与返回值类型相同的 所谓&lt;a href=&#34;https://en.wikipedia.org/wiki/Function_overloading&#34;&gt;Function Overloading&lt;/a&gt;。因此一个功能相同仅仅是为了处理不同参数类型的一组函数，非得费破脑细胞取给各个函数想名字，这也是很无奈的。&lt;/li&gt;
&lt;li&gt;Golang因为是 强类型 &amp;amp; 静态类型 的关系(C语言是 弱类型 &amp;amp; 静态类型)，很多在C语言，Java, C#中都可以隐式类型转换的写法在C语言中必须得做显式类型转换，代码就难免会多起来。感觉语言设计者想通过这种方式来甩锅啊&amp;hellip;&amp;hellip;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;不过，瑕不掩瑜。Golang还是一门非常值得学习的语言。2015年末我自学了Python，本来想好好研究一下Python的。结果一接触Golang之后，就立刻爱不释手，我想大概还是因为我是从C语言这一路学习过来的吧。所以我建议所有有C语言开发经验的人都取接触一下Golang，也许就会和我一样有“相见恨晚”的感觉。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>