<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>小wing的驿站</title>
    <link>https://xiaowing.github.io/tags/%E8%AF%91%E4%BD%9C/index.xml</link>
    <description>Recent content on 小wing的驿站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>&amp;copy; Licensed under CC BY-NC-SA.</copyright>
    <atom:link href="https://xiaowing.github.io/tags/%E8%AF%91%E4%BD%9C/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>[译文]Python为何会成为机器学习领域的主流语言</title>
      <link>https://xiaowing.github.io/post/20170913_python_and_machine_learning_cn/</link>
      <pubDate>Wed, 13 Sep 2017 21:37:02 +0800</pubDate>
      
      <guid>https://xiaowing.github.io/post/20170913_python_and_machine_learning_cn/</guid>
      <description>&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;pure-u-1-1&#34;&gt;
    &lt;div style=&#34;padding: 0 .2em&#34;&gt;
      &lt;img
        class=&#34;pure-img-responsive&#34;
        src=&#34;https://xiaowing.github.io/img/post/python-logo.png&#34;
        alt=&#34;Python Logo&#34;&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;


&lt;p&gt;最近因为在改PostgreSQL的相关的一些代码，因此在自学Perl语言。虽然和Python一样，它也是门解释型语言，然而这门语言真的是比较奇葩，因此无比地怀念Python.&lt;/p&gt;

&lt;p&gt;Python是我2015年自学的，虽然没用它做过什么正经的项目，但是小东西还是写了不少。只可惜自己终究还是修行不够，否则在目前这个被&amp;rdquo;人工智能&amp;rdquo;，“机器学习”等概念刷屏的年代，借助Python这门深受机器学习领域欢迎的语言，我说不定也能包装成一个年薪百万的大咖~&lt;/p&gt;

&lt;p&gt;不过，为什么机器学习领域会如此欢迎Python？之前在一个日文网站上看到一篇文章说这个事情，我觉得写得有点意思，所以就把它翻译了一下&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;python为何会成为机器学习领域的主流语言&#34;&gt;Python为何会成为机器学习领域的主流语言&lt;/h2&gt;

&lt;p&gt;原题: 機械学習でPythonが主流になっている必然的な理由とは&lt;/p&gt;

&lt;p&gt;作者: 株式会社キャパ&lt;/p&gt;

&lt;p&gt;链接: &lt;a href=&#34;http://www.capa.co.jp/archives/13875&#34;&gt;http://www.capa.co.jp/archives/13875&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0&#34;&gt;机器学习&lt;/a&gt;,或者说&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0&#34;&gt;深度学习&lt;/a&gt;的领域, Python正成为主流的编程语言。&lt;/p&gt;

&lt;p&gt;在海外，Python是作为一个用于编程教育的语言而慢慢普及开来的;但是在日本国内，Python则几乎没怎么受到过关注(&lt;em&gt;译注: 相对于Python，日本业界对于Ruby的关注度更高，大概因为Ruby是日本人发明的吧&lt;/em&gt;).那么，为什么在机器学习领域Python会成为主流呢？这其中有以下几个缘由:&lt;/p&gt;

&lt;h3 id=&#34;为什么选择了python-而不是c&#34;&gt;为什么选择了Python，而不是C++?&lt;/h3&gt;

&lt;p&gt;你知道解释型语言(通称:脚本语言)与编译型语言的差异吗？&lt;/p&gt;

&lt;p&gt;前者以Python以及Ruby为代表的语言，后者则因C语言或C++而广为人知。解释型语言是不管你将代码写到什么程度，随时都可以把写好的代码立刻运行起来;但是后者的编译型语言则必须遵循一定的编译手顺生成可执行文件之后，然后才能把它执行起来。编译型语言需要开发者在编译上花费一定的时间以及精力，但相对的，它的执行起来的性能是非常高速的。&lt;/p&gt;

&lt;p&gt;在机器学习领域，往往会涉及到大量的计算。理论上处理速度应该是越快越好，但为什么它选择了不是编译型语言的Python？其中有这么几点原因:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;“编码-运行”的周期可以变得更短&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在机器学习，或者深度学习领域，往往需要开发者写了代码以后立刻运行一下，根据运行结果进而修正相应的代码，之后再执行——这样的循环过程在实际开发中会再三反复。如果在这样的开发中选用了编译型语言，也就意味着在开发过程中实际上又要加入一个编译的过程，因此可以预见开发的生产性会下降。&lt;/p&gt;

&lt;p&gt;而且在编译型语言中，数据的&amp;rdquo;类型&amp;rdquo;是很受重视的，但是Python却是一个动态类型的语言，因此编码中根本无需声明数据的类型。对于同时有可能处理各种数据的机器学习而言，如果是用重视类型的编译型语言去一个个事先定义好数据的类型，写代码的时间应该会被拉长不少吧。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;拥有各种各样的涉及高速运算的程序库&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在Python中，拥有以&lt;code&gt;Numpy&lt;/code&gt;和&lt;code&gt;Scipy&lt;/code&gt;为代表的高速处理数值计算的程序库。因为有了这些库，尽管Python是解释型语言，但是可以借助它们的高速化而使人们不再对Python性能而感到担心。除此之外，还有&lt;code&gt;Matplotlib&lt;/code&gt;之类的绘图库，因此可以很简单地将机器学习的结果以图或表的形式展现出来。再借助&lt;code&gt;Django&lt;/code&gt;这个Web框架，就可以将机器学习的结果很方便地公开为一个Web服务，&lt;/p&gt;

&lt;p&gt;当然，Python中用于机器学习以及深度学习的各种程序库还在不断充实中。比如享誉业界的Google出品的&lt;code&gt;TensorFlow&lt;/code&gt;框架,以及&lt;code&gt;Caffe&lt;/code&gt;, &lt;code&gt;Scikit-learn&lt;/code&gt;, &lt;code&gt;Theano&lt;/code&gt;等等。Python中这些程序库/框架的充实度以及Python在机器学习中的流行度这两者之间，现在已经说不清到底是先有的鸡还是先有的蛋。总之，随着用户的增多，Python在机器学习方面的生态也的确会越变越好吧。&lt;/p&gt;

&lt;h3 id=&#34;r语言-与-python&#34;&gt;R语言 与 Python&lt;/h3&gt;

&lt;p&gt;R语言是数据科学家们用于进行数据统计的一门语言。而机器学习以及深度学习的知识领域其实与数据科学在很多方面是重合的。此外，在最初的阶段，R语言的程序库的性能普遍要更好。因此，一开始的时候普遍认为R语言会成为该领域的主流。&lt;/p&gt;

&lt;p&gt;但是，机器学习毕竟是需要通过软件开发人员来落地并实现的，比起只在数据科学家圈子中运用的R语言，对于软件开发人员而言，如果能用相对熟悉的Python语言来做，那当然会倾向于选择用Python来实现。因此，最终反而是Python中这方面的程序库变得更加充实起来。&lt;/p&gt;

&lt;h3 id=&#34;时势造就的python英雄&#34;&gt;时势造就的Python英雄&lt;/h3&gt;

&lt;p&gt;就结果而言，Python现今成了机器学习领域的主流语言。不过，这其实也谈不上是“必然”，只是经由时代选择而得到的一个结果而已。今后也许会发明一种专门面向机器学习领域的语言也说不定。只是目前还是暂时让Python的时代继续一段时间吧。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[译文]GO语言是面向对象的吗？</title>
      <link>https://xiaowing.github.io/post/20170816_is_go_object_oriented_cn/</link>
      <pubDate>Wed, 16 Aug 2017 21:48:52 +0800</pubDate>
      
      <guid>https://xiaowing.github.io/post/20170816_is_go_object_oriented_cn/</guid>
      <description>&lt;p&gt;周一在微信上收到了&lt;a href=&#34;http://www.weixinyidu.com/a_277786&#34;&gt;Go中国&lt;/a&gt;公众号推送的一篇文章 &lt;a href=&#34;https://flaviocopes.com/golang-is-go-object-oriented/&#34;&gt;Is GO object oriented&lt;/a&gt; ,读完以后感觉观点还是很有意思的，与我的所见有很多相似之处，所以就饶有兴趣地把它翻译成中文，也算是作为&amp;rdquo;友军&amp;rdquo;的一点贡献吧&amp;hellip;&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;go语言是面向对象的吗&#34;&gt;GO语言是面向对象的吗？&lt;/h2&gt;

&lt;p&gt;原题: IS GO OBJECT ORIENTED?&lt;/p&gt;

&lt;p&gt;作者: Flavio Copes&lt;/p&gt;

&lt;p&gt;链接: &lt;a href=&#34;https://flaviocopes.com/golang-is-go-object-oriented/&#34;&gt;https://flaviocopes.com/golang-is-go-object-oriented/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;有时候我会读到文章宣称&amp;rdquo;GO语言是面向对象的语言&amp;rdquo;，有时候我又会读到一篇持相反观点的文章宣称&amp;rdquo;GO语言无法做到面向对象编程因为它根本没有&amp;rsquo;类&amp;rsquo;&amp;ldquo;.&lt;/p&gt;

&lt;p&gt;有鉴于此，我写了这篇文章来阐述这个话题: &lt;strong&gt;GO语言到底是不是面向对象的语言&lt;/strong&gt;？&lt;/p&gt;

&lt;p&gt;如果你习惯了从某种特定编程语言的视角来思考问题，那么在这个话题上，你可能会由于自己所惯于使用的语言不同而得出截然相反的答案。比如说，如果你之前习惯了使用C语言，那么很显然GO语言拥有太多面向对象的特性；但是如果你之前习惯了使用Java，那么GO语言看起来就不那么&amp;rdquo;面向对象&amp;rdquo;了。&lt;/p&gt;

&lt;p&gt;因此关于这个话题，你首先要做的是摒弃其他语言带给你的先入为主的观念并学会用GO语言的思维模式来思考。&lt;/p&gt;

&lt;p&gt;然后我就可以给出我的答案了: YES. GO语言是一门面向对象的语言, 而且是以一种很清爽的方式实现了面向对象.&lt;/p&gt;

&lt;p&gt;在&lt;a href=&#34;https://golang.org/doc/faq#Is_Go_an_object-oriented_language&#34;&gt;GO语言官方文档的FAQ&lt;/a&gt;中也表述过下述内容&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Is Go an object-oriented language?&lt;/p&gt;

&lt;p&gt;Yes and no. Although Go has types and methods and
allows an object-oriented style of programming, there
is no type hierarchy. The concept of “interface” in Go
provides a different approach that we believe is easy
to use and in some ways more general. There are also
ways to embed types in other types to provide something
analogous—but not identical—to subclassing. Moreover,
methods in Go are more general than in C++ or Java:
they can be defined for any sort of data, even built-in
types such as plain, “unboxed” integers. They are not
restricted to structs (classes).
Also, the lack of a type hierarchy makes “objects” in
Go feel much more lightweight than in languages such as
C++ or Java.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;集众家所长&#34;&gt;集众家所长&lt;/h3&gt;

&lt;p&gt;GO语言从&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E8%BF%87%E7%A8%8B%E5%BC%8F%E7%BC%96%E7%A8%8B&#34;&gt;过程式编程语言&lt;/a&gt;, &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B8%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80&#34;&gt;函数式编程语言&lt;/a&gt;以及&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1&#34;&gt;面向对象编程语言&lt;/a&gt;中都汲取了一些概念并将它们组装在一起后，将那些剩余的概念舍弃从而创造了一门极具特性但又十分地道的编程语言。&lt;/p&gt;

&lt;h3 id=&#34;要结构体-不要类&#34;&gt;要结构体,不要类&lt;/h3&gt;

&lt;p&gt;GO语言中并没有传统面向对象编程语言中的&amp;rdquo;类&amp;rdquo;(&lt;code&gt;class&lt;/code&gt;)的概念，取而代之的是使用了&amp;rdquo;结构体&amp;rdquo;(&lt;code&gt;struct&lt;/code&gt;)。但是GO语言的结构体可比C语言中的同名前辈要强大得多。在GO语言中,结构体以及结构体的方法(&lt;code&gt;method&lt;/code&gt;)发挥了与传统意义上的&amp;rdquo;类&amp;rdquo;相同的作用，同时在概念上又清晰分明——结构体只负责管理状态，不管理行为;而结构体的方法则负责定义结构体的行为，比如说允许他们更改状态.&lt;/p&gt;

&lt;h3 id=&#34;封装的奥义&#34;&gt;封装的奥义&lt;/h3&gt;

&lt;p&gt;我认为GO语言中最好的一个特性就是，直接明了地通过字段名, 方法名以及函数名的首字母大写来保证它们的访问可见性为&lt;strong&gt;public&lt;/strong&gt;。其他的那些以小写字母开头的字段等则默认为包(&lt;code&gt;package&lt;/code&gt;)内私有(private)并且无法被导出至包外。这个特性使得开发者们一眼就可以看出来哪些字段/方法/属性是public的，哪些是private的。另外，由于GO语言中没有&lt;strong&gt;继承&lt;/strong&gt;这一概念，所以GO语言中的访问修饰也就根本没有&lt;code&gt;protected&lt;/code&gt;的概念.&lt;/p&gt;

&lt;h3 id=&#34;无继承&#34;&gt;无继承&lt;/h3&gt;

&lt;p&gt;GO语言中没有&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%BB%A7%E6%89%BF_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)&#34;&gt;继承&lt;/a&gt;,这一点在&lt;a href=&#34;https://golang.org/doc/faq#Why_is_there_no_type_inheritance&#34;&gt;GO语言官方文档的FAQ&lt;/a&gt;也有明确说明:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Object-oriented programming, at least in the best-known
languages, involves too much discussion of the
relationships between types, relationships that often
could be derived automatically. Go takes a different
approach.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;用组合代替继承&#34;&gt;用组合代替继承&lt;/h3&gt;

&lt;p&gt;程序设计理念中最广为认知的准则之一即是 &lt;a href=&#34;https://en.wikipedia.org/wiki/Composition_over_inheritance&#34;&gt;用组合代替继承&lt;/a&gt;。这一准则在&lt;a href=&#34;https://en.wikipedia.org/wiki/Design_Patterns&#34;&gt;四人帮&lt;/a&gt;的那本极富盛名的《设计模式》也屡有提及。而在GO语言中，这一准则被发挥得淋漓尽致。&lt;/p&gt;

&lt;p&gt;当我们在定义一个结构体时，我们可以追加类型为另一个结构体的匿名字段。这样一来，我们定义的这个结构体也就同时拥有了另一个结构体的所有字段以及方法。这种技法被称之为&lt;strong&gt;Struct Embedding&lt;/strong&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

type Dog struct {
	Animal
}
type Animal struct {
	Age int
}

func (a *Animal) Move() {
	fmt.Println(&amp;quot;Animal moved&amp;quot;)
}
func (a *Animal) SayAge() {
	fmt.Printf(&amp;quot;Animal age: %d\n&amp;quot;, a.Age)
}
func main() {
	d := Dog{}
	d.Age = 3
	d.Move()
	d.SayAge()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://play.golang.org/p/IxMoeByWp5&#34;&gt;执行结果&lt;/a&gt; (需要科学上网)&lt;/p&gt;

&lt;h3 id=&#34;接口&#34;&gt;接口&lt;/h3&gt;

&lt;p&gt;忘记Java或PHP风格的接口概念吧！GO语言中的接口是截然不同的，而其中最关键的一个特性即是: &lt;strong&gt;接口是隐式实现的&lt;/strong&gt;——不需要在定义类型时去显式声明一下类型实现了哪些接口。&lt;/p&gt;

&lt;p&gt;还是摘抄自&lt;a href=&#34;https://golang.org/doc/faq#Why_is_there_no_type_inheritance&#34;&gt;GO语言官方文档的FAQ&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Rather than requiring the programmer to declare ahead
of time that two types are related, in Go a type
automatically satisfies any interface that specifies a
subset of its methods.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通常，接口的定义都很短，甚至有可能至包含一个方法声明。在地道的GO语言实践中，你不应该看到一个接口拥有长长的方法列表。&lt;/p&gt;

&lt;p&gt;借助这样的接口就可以很优雅地实现&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%9E%8B_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)&#34;&gt;多态&lt;/a&gt;: 一个方法如果接受某一个接口，那么就意味着这个方法接受了任何实现了该接口的对象.&lt;/p&gt;

&lt;h3 id=&#34;方法&#34;&gt;方法&lt;/h3&gt;

&lt;p&gt;GO语言中的类型往往都拥有方法，但是这些方法的定义是独立于类型定义而存在的。GO语言在语法层面通过一个类似Javascript中prototype方法的特性来实现了这种定义的独立性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Person(first, last) {
    this.firstName = first;
    this.lastName = last;
}
Person.prototype.name = function() {
    return this.firstName + &amp;quot; &amp;quot; + this.lastName;
};
p = new Person(&amp;quot;Flavio&amp;quot;, &amp;quot;Copes&amp;quot;)
p.name() // Flavio Copes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在GO语言中，代码应该写成这样:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)
type Person struct {
	firstName string
	lastName  string
}
func (p Person) name() string {
	return p.firstName + &amp;quot; &amp;quot; + p.lastName
}
func main() {
	p := Person{&amp;quot;Flavio&amp;quot;, &amp;quot;Copes&amp;quot;}
	fmt.Println(p.name())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;关联方法与类型&#34;&gt;关联方法与类型&lt;/h3&gt;

&lt;p&gt;方法可以被关联至任何类型,甚至是&amp;rdquo;曲线救国&amp;rdquo;式地关联到GO语言中的基础类型。由于方法只能被关联至在同一个包中定义的类型,所以我们无法直接&amp;rdquo;扩展&amp;rdquo;基础类型。但事实上，我们可以通过对基础数据类型定义别名从而达到扩展的目的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

type Amount int

func (a *Amount) Add(add Amount) {
	*a += add
}

func main() {
	var a Amount
	a = 1
	a.Add(2)
	fmt.Println(a)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://play.golang.org/p/ONlUmue1jA&#34;&gt;显示结果&lt;/a&gt; (需要科学上网)&lt;/p&gt;

&lt;h3 id=&#34;函数&#34;&gt;函数&lt;/h3&gt;

&lt;p&gt;让我们回想一下传统的面向对象编程语言吧，比如Java。想想看你曾经定义过多少次包含的全是static方法的名为&amp;rdquo;Utils&amp;rdquo;的类?&lt;/p&gt;

&lt;p&gt;这样的现象来源与传统的面向对象变成语言中的一个观念: &lt;strong&gt;一切皆是对象&lt;/strong&gt;，因此函数定义必须放在一个类里面。所幸的是，这种现象不会发生在GO语言中，因为GO语言有真正的&amp;rdquo;函数&amp;rdquo;这一概念。在真实世界中，并非所有事物都必须是一个对象。&amp;rdquo;类&amp;rdquo;和&amp;rdquo;对象&amp;rdquo;的概念很有用，但也不能到处都用。&lt;/p&gt;

&lt;p&gt;在GO语言中，并非所有东西都是对象(若严格从技术角度而言，GO语言没有东西是对象。但通常人们会将一个类型的实例或者变量称之为&amp;rdquo;对象&amp;rdquo;),方法仅仅是指那些被关联至某一类型的函数。但GO语言同时又允许函数脱离于对象而独立存在,就如同C语言的函数一样。&lt;/p&gt;

&lt;p&gt;所以，GO语言既允许方法存在，也允许函数存在。而且，函数是第一优先的(函数类型可用作定义结构体字段,函数可作为参数传递至其他函数，函数也可作为返回值被函数或方法返回)。&lt;/p&gt;

&lt;h3 id=&#34;大道至简&#34;&gt;大道至简&lt;/h3&gt;

&lt;p&gt;综上所述，GO语言对于面向对象的实现非常灵活且直接。不用再纠结于类和继承，你可以减少对源码模板文件的依赖，而且不用再一点一点地推敲类与类之间的理想层级结构，从此你只需根据需求自由地对类型进行组合或拆解即可。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>