<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>小wing的驿站</title>
    <link>https://xiaowing.github.io/topics/%E6%8A%80%E6%9C%AF/index.xml</link>
    <description>Recent content on 小wing的驿站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>&amp;copy; Licensed under CC BY-NC-SA.</copyright>
    <atom:link href="https://xiaowing.github.io/topics/%E6%8A%80%E6%9C%AF/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>我所理解的事务隔离级别</title>
      <link>https://xiaowing.github.io/post/20180127_db_isolation_level/</link>
      <pubDate>Sat, 27 Jan 2018 21:08:20 +0800</pubDate>
      
      <guid>https://xiaowing.github.io/post/20180127_db_isolation_level/</guid>
      <description>&lt;p&gt;我发现有不少做应用的技术人员对于数据库的一些常识概念其实是理解不清的，这就导致了他们设计的应用中往往充斥了数据访问的相关错误却浑然不知。所以其实我还是比较乐意普及一些数据库常识的。&lt;/p&gt;

&lt;p&gt;本文就是我在 &lt;a href=&#34;https://about.segmentfault.com/?utm_source=sf-footer&amp;amp;utm_medium=footer-nav&amp;amp;utm_campaign=about&amp;amp;utm_content=about-index&amp;amp;utm_term=%E5%85%B3%E4%BA%8E%E6%88%91%E4%BB%AC&#34;&gt;&lt;em&gt;segmentfault.com&lt;/em&gt;&lt;/a&gt; 上对 &amp;ldquo;&lt;strong&gt;怎么理解SQL的四个事务隔离级别？&lt;/strong&gt;&amp;ldquo;&lt;a href=&#34;https://segmentfault.com/q/1010000012178278/a-1020000012661683&#34;&gt;这个问题的回答&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;我认为要理解事务隔离级别，就必须先理解在并发事务场景下隔离的重要性。因此，对于并发读事务之间数据可见性的三种现象需要首先理解清楚。&lt;/p&gt;

&lt;p&gt;下面我将以下表为例直观说明这三种现象。&lt;/p&gt;



&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;pure-u-1-1&#34;&gt;
    &lt;div style=&#34;padding: 0 .2em&#34;&gt;
      &lt;img
        class=&#34;pure-img-responsive&#34;
        src=&#34;https://xiaowing.github.io/img/post/20180127/isolation_level_table.png&#34;
        alt=&#34;示例表&#34;&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;


&lt;h2 id=&#34;并发读的三种现象&#34;&gt;并发读的三种现象&lt;/h2&gt;

&lt;h3 id=&#34;脏读&#34;&gt;脏读&lt;/h3&gt;



&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;pure-u-1-1&#34;&gt;
    &lt;div style=&#34;padding: 0 .2em&#34;&gt;
      &lt;img
        class=&#34;pure-img-responsive&#34;
        src=&#34;https://xiaowing.github.io/img/post/20180127/isolation_level_dirty_read.png&#34;
        alt=&#34;dirty read&#34;&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;


&lt;p&gt;这种现象出现在事物间的隔离级别最差的场景下，写事务&lt;strong&gt;对一个元组的更新&lt;/strong&gt;尚未提交时就被另一个事务读到了。如果在一个业务应用中，写事务后面没提交而是回滚了，那么可以预见这个读事务读到的这个未提交的更新在某些业务场景下可能会带来一些困扰。&lt;/p&gt;

&lt;h3 id=&#34;不可重复读&#34;&gt;不可重复读&lt;/h3&gt;



&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;pure-u-1-1&#34;&gt;
    &lt;div style=&#34;padding: 0 .2em&#34;&gt;
      &lt;img
        class=&#34;pure-img-responsive&#34;
        src=&#34;https://xiaowing.github.io/img/post/20180127/isolation_level_unrepeatable_read.png&#34;
        alt=&#34;unrepeatable read&#34;&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;


&lt;p&gt;这种现象比上面的&lt;strong&gt;脏读&lt;/strong&gt;&amp;ldquo;好&amp;rdquo;一点，只有当写事务提交后，这个更新才会被读事务读取到。但是考虑到如上图所示，在同一个事务中的不同时间点意图读取同一个元组却读到了不同的数据，在某些业务场景下可能也会带来一些困扰。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;划重点： &amp;ldquo;脏读&amp;rdquo;和&amp;rdquo;不可重复读&amp;rdquo;这两个现象针对的是对于表中的&lt;strong&gt;同一个逻辑上的元组&lt;/strong&gt;而言.引发&amp;rdquo;脏读&amp;rdquo;和&amp;rdquo;不可重复读&amp;rdquo;这两个现象的写事务的操作通常是&lt;strong&gt;UPDATE&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;幻读&#34;&gt;幻读&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;幻读&lt;/strong&gt;这一现象针对的已不是表中的单一元组而言，而是指读事务在对表中的&lt;strong&gt;某个范围多个元组&lt;/strong&gt;而言的一种现象，引发幻读的写事务对应的操作通常是&lt;strong&gt;INSERT&lt;/strong&gt;或&lt;strong&gt;DELETE&lt;/strong&gt;。如下图所示：&lt;/p&gt;



&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;pure-u-1-1&#34;&gt;
    &lt;div style=&#34;padding: 0 .2em&#34;&gt;
      &lt;img
        class=&#34;pure-img-responsive&#34;
        src=&#34;https://xiaowing.github.io/img/post/20180127/isolation_level_phantom_read.png&#34;
        alt=&#34;phantom read&#34;&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;


&lt;p&gt;在同一个读事务中，对于同一个过滤条件查询出了不同的结果集，这在某些业务场景下也有可能带来一定的困扰。&lt;/p&gt;

&lt;h3 id=&#34;补充说明&#34;&gt;补充说明&lt;/h3&gt;

&lt;p&gt;上面这些就是关于&amp;rdquo;脏读&amp;rdquo;，&amp;rdquo;不可重复读&amp;rdquo;以及&amp;rdquo;幻读&amp;rdquo;这三个现象的介绍。除此之外，这边还需要再强调两个注意点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&amp;ldquo;脏读&amp;rdquo;，&amp;rdquo;不可重复读&amp;rdquo;以及&amp;rdquo;幻读&amp;rdquo;这三个现象&lt;strong&gt;不是错误,更不是BUG&lt;/strong&gt;。它们仅仅是事务并发场景下可能出现的现象。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;ldquo;脏读&amp;rdquo;，&amp;rdquo;不可重复读&amp;rdquo;以及&amp;rdquo;幻读&amp;rdquo;针对的是&lt;strong&gt;同一个事务&lt;/strong&gt;中的读操作而言。为什么要强调这一点，因为有些对数据库理解不深的同学不能很好的理解清楚 &lt;strong&gt;会话&lt;/strong&gt;,&lt;strong&gt;事务&lt;/strong&gt;和&lt;strong&gt;语句&lt;/strong&gt;这三个概念。于是对于以下的例子就会误认为是&amp;rdquo;不可重复读&amp;rdquo;的现象:&lt;/p&gt;



&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;pure-u-1-1&#34;&gt;
    &lt;div style=&#34;padding: 0 .2em&#34;&gt;
      &lt;img
        class=&#34;pure-img-responsive&#34;
        src=&#34;https://xiaowing.github.io/img/post/20180127/read_exception.jpg&#34;
        alt=&#34;例外&#34;&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;


&lt;p&gt;但实际上，在这个例子中&lt;strong&gt;会话2&lt;/strong&gt;的SQL是按&lt;strong&gt;隐式事务&lt;/strong&gt;来执行，其执行的两条&lt;code&gt;SELECT name FROM foo WHERE id = 1;&lt;/code&gt;实际上是分属两个不同的读事务。对于后执行的那条SELECT文所属的隐式事务，由于其执行时会话1的更新已经提交，所以它理所当然地可以读到更新后的数据。这与&amp;rdquo;不可重复读&amp;rdquo;的概念没有任何关系。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;如何理解事务隔离级别&#34;&gt;如何理解事务隔离级别&lt;/h2&gt;

&lt;h3 id=&#34;事务隔离级别与上述三现象的关系&#34;&gt;事务隔离级别与上述三现象的关系&lt;/h3&gt;

&lt;p&gt;理解清楚了以上的这三个&amp;rdquo;读&amp;rdquo;的概念后，就可以很容易的理解事务隔离级别了。因为事务隔离级别的设置本质上就意味着让你控制并发事务之间的写事务带来的数据更新的对于同时正在执行的其他事务的可见性——即，&lt;strong&gt;你允许业务中的并发事务之间出现怎样的都现象&lt;/strong&gt;. 由于&amp;rdquo;脏读&amp;rdquo;，&amp;rdquo;不可重复读&amp;rdquo;以及&amp;rdquo;幻读&amp;rdquo;的概念是一种层层递进的概念，因此事务隔离级别从&amp;rdquo;Read Uncommited&amp;rdquo;到&amp;rdquo;Serializable&amp;rdquo;也是一个比一个严格。&lt;/p&gt;

&lt;p&gt;SQL标准中对于隔离级别与事务之间数据可见性的关系定义如下:&lt;/p&gt;



&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;pure-u-1-1&#34;&gt;
    &lt;div style=&#34;padding: 0 .2em&#34;&gt;
      &lt;img
        class=&#34;pure-img-responsive&#34;
        src=&#34;https://xiaowing.github.io/img/post/20180127/isolation_read.png&#34;
        alt=&#34;读隔离&#34;&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;


&lt;p&gt;需要注意的是，SQL标准中对于这些隔离级别定义中约束的&amp;rdquo;不允许&amp;rdquo;现象是强制要求的。数据库厂商在宣称支持某个隔离级别时，必须将上表中对应隔离级别的&amp;rdquo;不允许&amp;rdquo;进行实现。但是对于&amp;rdquo;可能&amp;rdquo;项则不代表你必须实现成具备某种都现象。比如在PostgreSQL中，由于其MVCC的实现，&lt;code&gt;REPEATABLE READ&lt;/code&gt;对于读事务的行为实现也和&lt;code&gt;SERIALIZABLE&lt;/code&gt;一样是不会出现幻读的，而&lt;code&gt;REPEATABLE READ&lt;/code&gt;和&lt;code&gt;SERIALIZABLE&lt;/code&gt;的区别，主要体现在下文所述的对更新操作的约束力度上。&lt;/p&gt;

&lt;h3 id=&#34;serializable对写操作的约束&#34;&gt;SERIALIZABLE对写操作的约束&lt;/h3&gt;

&lt;p&gt;在其他隔离级别中，如果并发的两个事务同时意图对同一个元组进行更新时，后更新的事务会等待直到先更新的事务提交后在继续执行其更新操作。 但是在&lt;strong&gt;SERIALIZABLE&lt;/strong&gt;的情况下，由于此时事务隔离级别最强，会对有可能对读一致性带来影响的写操作必须按照事务的串行执行。在PG的实现中，这表现为尝试对于同一元组进行更新的并发事务会在等待完先更新的事务提交后自己报个错：&lt;/p&gt;



&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;pure-u-1-1&#34;&gt;
    &lt;div style=&#34;padding: 0 .2em&#34;&gt;
      &lt;img
        class=&#34;pure-img-responsive&#34;
        src=&#34;https://xiaowing.github.io/img/post/20180127/write_serializable.jpg&#34;
        alt=&#34;可串行化的写约束&#34;&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;


&lt;p&gt;在&lt;strong&gt;SERIALIZABLE&lt;/strong&gt;隔离级别下，对于上图中的两个更新事务若都希望成功，需要保证右边会话的更新操作所属事务的&lt;code&gt;START TRANSACTION&lt;/code&gt;必须发生在左边会话的更新事务&lt;code&gt;COMMIT&lt;/code&gt;之后，即两个写事务真正是&amp;rdquo;串行&amp;rdquo;的。&lt;/p&gt;

&lt;p&gt;以上就是我对事务隔离级别的认识。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>在Ubuntu 16.04上从源码编译安装go1.9.2</title>
      <link>https://xiaowing.github.io/post/20171226_install_golang_fromsrc_ubuntu/</link>
      <pubDate>Fri, 22 Dec 2017 11:37:20 +0800</pubDate>
      
      <guid>https://xiaowing.github.io/post/20171226_install_golang_fromsrc_ubuntu/</guid>
      <description>&lt;p&gt;这两天在虚拟机上新装了一个 &lt;a href=&#34;http://releases.ubuntu.com/16.04/&#34;&gt;Ubuntu Server 16.04LTS&lt;/a&gt;,于是很自然地想安装一个Go语言环境。以往无论在Windows上还是在Linux上都是用的现成的二进制distribute包来安装Go, 但是这次打算尝试用源码来直接编译安装。于是把本次编译安装的一些手顺和注意事项分享在本文中:&lt;/p&gt;



&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;pure-u-1-1&#34;&gt;
    &lt;div style=&#34;padding: 0 .2em&#34;&gt;
      &lt;img
        class=&#34;pure-img-responsive&#34;
        src=&#34;https://xiaowing.github.io/img/post/20171226/ubuntu-go.png&#34;
        alt=&#34;Go on Ubuntu&#34;&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;


&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;编译安装过程&#34;&gt;编译安装过程&lt;/h2&gt;

&lt;p&gt;得益于Go语言团队的强大技术，Go语言的编译安装非常智能化，整个编译安装过程非常惬意。不过，由于Go语言从1.5版本开始就实现了&lt;a href=&#34;http://www.cnblogs.com/lidyan/p/6727184.html&#34;&gt;自举&lt;/a&gt;, 因此对于一个只有gcc编译环境的几乎等同于一张白纸的系统，必须先编译安装一个1.5以前版本的Go语言，之后再用这个低版本去编译1.9.2的Go语言。&lt;/p&gt;

&lt;p&gt;以下安装过程是在以下环境中实施的&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;操作系统: Ubuntu Server 16.04&lt;/li&gt;
&lt;li&gt;CPU架构:  x86-64&lt;/li&gt;
&lt;li&gt;gcc版本:  5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.5)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;使用gcc编译go-1-4&#34;&gt;使用gcc编译Go 1.4&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Go 1.4的编译依赖于glibc，因此首先需要在Ubuntu上确保安装了新版的glibc&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$sudo apt-get install libc-dev
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下载解压 go1.4源码, 并进行编译。由于编译脚本写得非常好，这一步没有什么特别的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$wget -c -t 3  https://storage.googleapis.com/golang/go1.4-bootstrap-20170531.tar.gz
$tar zxvf go1.4-bootstrap-20170531.tar.gz
$cd ~/go/src
$./all.bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;all.bash脚本执行编译后，会对1.4的各个pkg进行回归测试。这里可能会有一点问题，具体会在后文描述。总之，当编译完成后，会在&lt;code&gt;~/go&lt;/code&gt;目录下生成一个&lt;code&gt;bin&lt;/code&gt;目录，里面有生成的可执行文件&lt;code&gt;go&lt;/code&gt;; 且所有go语言的标准库会生成在&lt;code&gt;~/go/pkg/linux_amd64&lt;/code&gt;目录下(我是x86-64的虚拟机，因此目录名是&lt;code&gt;linux_amd64&lt;/code&gt;。该目录名会因操作系统以及体系架构不同而变化)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用Go语言自举时，需要创建GOROOT_BOOTSTRAP环境变量，指向低版本的Go语言环境。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$cd ~/go/
$export GOROOT_BOOTSTRAP=`pwd`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&lt;code&gt;echo&lt;/code&gt;命令查看该环境变量&lt;code&gt;$echo ${GOROOT_BOOTSTRAP}&lt;/code&gt;，确认它指向的是Go1.4的路径即可.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;/home/wing/go&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;使用go-1-4编译-go-1-9-2&#34;&gt;使用Go 1.4编译 Go 1.9.2&lt;/h3&gt;

&lt;p&gt;这样一来，用于自举的低版本的Go语言便已编译安装完毕，接下来就用它编译安装 Go 1.9.2&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载并编译 1.9.2 , 整个过程仍然无比惬意&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$wget -c -t 3 https://github.com/golang/go/archive/go1.9.2.tar.gz
$cd ~
$tar zxvf go-go1.9.2.tar.gz
$cd ~/go-go1.9.2/src
$./all.bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果编译过程没有问题的话，那么标准输出中就会输出类似以下的信息&lt;/p&gt;

&lt;blockquote&gt;
&lt;h2 id=&#34;all-tests-passed&#34;&gt;ALL TESTS PASSED&lt;/h2&gt;

&lt;p&gt;Installed Go for linux/amd64 in /home/wing/go-go1.9.2
Installed commands in /home/wing/go-go1.9.2/bin&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;由于我是让这个Go语言语言环境在整个系统内生效，而不是装在我的个人home目录下，因此我还要做以下事项。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;移至/opt目录下并使安装全局生效&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$cd ~
$sudo mv go-go1.9.2 /opt/.
$sudo vi /etc/profile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;/etc/profile&lt;/code&gt;文件底部增加下述变量导出&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export GOROOT=/opt/go-go1.9.2
export PATH=$GOROOT/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;此时，切换shell会话测试上述安装设置。&lt;/p&gt;

&lt;p&gt;$ go version&lt;/p&gt;

&lt;p&gt;这时理应输出以下信息:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;go version go1.9.2 linux/amd64&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;至此，整个Go 1.9.2的编译安装就圆满达成&lt;/p&gt;

&lt;h2 id=&#34;一点注意事项&#34;&gt;一点注意事项&lt;/h2&gt;

&lt;p&gt;在编译Go 1.4时，&lt;code&gt;all.bash&lt;/code&gt;最后的回归测试中，有可能会在下述测试中出错并进而打印出出错消息, 从而没有打印出预期的&lt;strong&gt;ALL TESTS PASSED&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; dial_test.go  all connections connected; expected some to time out
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过，即使出现上述现象也不是意味着编译出了问题。真的要论“锅”属于谁的话，其实它属于 Go语言团队。 根据&lt;a href=&#34;https://github.com/golang/go/issues/3307&#34;&gt;这个issue&lt;/a&gt;的相关讨论，该现象有大概率会在 64位Linux的 6g环境(即 x84-64 体系的gcc环境)中编译测试稍低版本的Go代码时出现。为了避免这个现象，Go团队也在后续更新中对&lt;code&gt;dial_test.go&lt;/code&gt;这个测试代码进行了改善(按: 感觉就是把超时时长拉长了一点&amp;hellip;)&lt;/p&gt;

&lt;p&gt;-以上-&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>揭秘PG —— 无处不在的OID</title>
      <link>https://xiaowing.github.io/post/20171117_pg_knowhow_oid/</link>
      <pubDate>Fri, 17 Nov 2017 23:08:31 +0800</pubDate>
      
      <guid>https://xiaowing.github.io/post/20171117_pg_knowhow_oid/</guid>
      <description>&lt;p&gt;由于手头当前的工作是基于PostgreSQL(以下简称&lt;strong&gt;PG&lt;/strong&gt;)做二次开发，因此目前对PG的源码也或多或少地读了一些，因此便想到了在博客里分享一些关于阅读PG源码所获得的KnowHow。&lt;/p&gt;

&lt;p&gt;在国内的PG技术圈内，提到PG源码解读自然首推武汉大学的两位彭老师所著的&lt;a href=&#34;https://book.douban.com/subject/6971366/&#34;&gt;《PostgreSQL数据库内核分析》&lt;/a&gt;。不过这本书的着眼点是对PG源码的整体架构，以及SQL引擎，存储系统，事务处理等等这些实现机制&amp;amp;算法的介绍，而我则主要想分享一些PG代码中的一些有意思的小细节/小功能。虽然只是PG那几百万行源码中的沧海一粟，不过从这些小细节中解读程序设计的匠心也是颇有意思的。&lt;/p&gt;



&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;pure-u-1-1&#34;&gt;
    &lt;div style=&#34;padding: 0 .2em&#34;&gt;
      &lt;img
        class=&#34;pure-img-responsive&#34;
        src=&#34;https://xiaowing.github.io/img/post/PostgreSQL_logo_120x120.png&#34;
        alt=&#34;PostgreSQL Logo&#34;&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;


&lt;p&gt;第一篇就从PG中无处不在的&lt;strong&gt;OID&lt;/strong&gt;开始吧&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;什么是oid&#34;&gt;什么是OID&lt;/h2&gt;

&lt;p&gt;关于PG中OID(&lt;em&gt;Object Identifier&lt;/em&gt;)的概念在&lt;a href=&#34;https://www.postgresql.org/docs/9.6/static/datatype-oid.html&#34;&gt;PostgreSQL官方手册&lt;/a&gt;有比较详细的介绍。简短洁说就是PostgreSQL内部用于标识数据库对象(即通常意义上的&lt;strong&gt;数据表&lt;/strong&gt;，&lt;strong&gt;视图&lt;/strong&gt;，&lt;strong&gt;存储过程&lt;/strong&gt;之类)的一个长度为&lt;strong&gt;4字节&lt;/strong&gt;的标识符。它是PostgreSQL大部分&lt;a href=&#34;https://www.postgresql.org/docs/9.6/static/catalogs.html&#34;&gt;系统表&lt;/a&gt;的主键。PostgreSQL一个为人称道的特点就是其提供了超强的扩展性，用户甚至可以对PostgreSQL的数据类型, 运算符, 存储过程语言进行扩展。而支撑其扩展性的基盘就是&lt;strong&gt;系统表&lt;/strong&gt;和&lt;strong&gt;OID&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;OID在系统表中通常是作为隐藏列存在的，它是以整个PostgreSQL数据库实例(&lt;a href=&#34;https://www.postgresql.org/docs/9.6/static/catalogs.html&#34;&gt;&lt;strong&gt;Database Cluster&lt;/strong&gt;&lt;/a&gt;)的范围内统一分配。在单个系统表内保存的OID一定可以保证OID的唯一性，但是OID不能保证跨系统表之间的唯一性 —— 也就是说，&lt;strong&gt;可以假定&lt;/strong&gt;&amp;ldquo;两个存储过程对象的OID不可能相同&amp;rdquo;; 但是&lt;strong&gt;绝不能假设&lt;/strong&gt;&amp;ldquo;一个表对象的OID肯定不等于一个存储过程对象的OID&amp;rdquo;(尽管在大部分情况下确实不相等)。此外，对于用户定义的数据表，PostgreSQL默认不会为其中的元组分配OID，除非建表时显式指定(其实PostgreSQL并不鼓励用户建表时指定包含OID, 并且不赞成用户的业务逻辑依赖于普通数据表的OID)。&lt;/p&gt;

&lt;p&gt;由于OID是系统表的隐藏列，因此查看系统表中数据库对象的OID时，必须在SELECT语句中显式指定。下图显示了如何查看一个新创建的Database对象的OID:&lt;/p&gt;



&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;pure-u-1-1&#34;&gt;
    &lt;div style=&#34;padding: 0 .2em&#34;&gt;
      &lt;img
        class=&#34;pure-img-responsive&#34;
        src=&#34;https://xiaowing.github.io/img/post/20171117/select_oid_sample.png&#34;
        alt=&#34;how to query oid&#34;&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;


&lt;p&gt;但是，对于一个使用&lt;code&gt;CREATE TABLE&lt;/code&gt;创建的普通表，PG默认不会为表中的元组保存OID, 自然执行SELECT语句时也无法查到oid这一列。比如下图所示:&lt;/p&gt;



&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;pure-u-1-1&#34;&gt;
    &lt;div style=&#34;padding: 0 .2em&#34;&gt;
      &lt;img
        class=&#34;pure-img-responsive&#34;
        src=&#34;https://xiaowing.github.io/img/post/20171117/query_oid_table_withoutoids.png&#34;
        alt=&#34;a table by default&#34;&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;


&lt;p&gt;如果希望在向表中插入数据时让PG为每一个元组生成OID，则需要在&lt;code&gt;CREATE TABLE&lt;/code&gt;时显式地加上&lt;code&gt;WITH OIDS&lt;/code&gt;这个属性。如下所示:&lt;/p&gt;



&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;pure-u-1-1&#34;&gt;
    &lt;div style=&#34;padding: 0 .2em&#34;&gt;
      &lt;img
        class=&#34;pure-img-responsive&#34;
        src=&#34;https://xiaowing.github.io/img/post/20171117/query_oid_table_withoids.png&#34;
        alt=&#34;a table with oids&#34;&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;


&lt;p&gt;&lt;em&gt;需要注意的是，尽管默认情况下PG不会为用户数据表的元组分配OID，但是对于用户创建的每一张表，PG还是会生成一个OID在系统表进行标识&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;oid机制的实现&#34;&gt;OID机制的实现&lt;/h2&gt;

&lt;p&gt;接下来将从以下几个方面聊一聊PG中关于OID机制的实现&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;OID的保存与共享&lt;/li&gt;
&lt;li&gt;OID的分配机制&lt;/li&gt;
&lt;li&gt;OID的持久化&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;oid的保存与共享&#34;&gt;OID的保存与共享&lt;/h3&gt;

&lt;p&gt;众所周知PG是一个多进程架构的数据库，每个用户会话对应了一个postgres进程, 由于受用户的DDL语句/DML语句操作，每一个postgres进程都有可能同时要求分配新的OID; 与此同时实例内部的一些常驻后台进程的动作也可能要求分配新的OID。因此若要实现整个实例范围内的OID统一管理，那么通常首选方案就是&lt;strong&gt;共享内存&lt;/strong&gt;, 事实上PG也是这么做的:&lt;/p&gt;

&lt;p&gt;首先，PG中设计了一个&lt;code&gt;VariableCacheData&lt;/code&gt;结构体来存放OID相关的数据:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* include/access/transam.h */
typedef struct VariableCacheData
{
	Oid	nextOid;    /* 保存了下一个要分配的OID */
	uint32 oidCount;    /* 剩余可用的OID个数 */

	TransactionId nextXid;
	TransactionId oldestXid;
	TransactionId xidVacLimit;
	TransactionId xidWarnLimit;
	TransactionId xidStopLimit;
	TransactionId xidWrapLimit;
	Oid	   oldestXidDB;

	TransactionId oldestCommitTsXid;
	TransactionId newestCommitTsXid;

	TransactionId latestCompletedXid;	
} VariableCacheData;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在整个数据库实例的运行期间，只会在实例启动时(也就是Postmaster进程启动时)在共享内存内创建一个&lt;code&gt;VariableCacheData&lt;/code&gt;结构体实例，同时Postmaster进程会将自己的&lt;code&gt;VariableCache&lt;/code&gt;类型(本质上就是VariableCacheData指针)的全局变量&lt;code&gt;ShmemVariableCache&lt;/code&gt;赋值为共享内存中&lt;code&gt;VariableCacheData&lt;/code&gt;结构体的地址。由于在linux上通过&lt;code&gt;fork()&lt;/code&gt;创建子进程时子进程会继承父进程的所有资源——包括全局变量。因此在实例运行过程中，Postmaster的子进程(含所有postgres进程以及其余的常驻后台进程)也就都共享了这个结构体的地址。&lt;/p&gt;

&lt;p&gt;全局变量&lt;code&gt;ShmemVariableCache&lt;/code&gt;的定义以及初始化的代码如下所示:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;变量定义&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* backend/access/transam/varsup.c */
...(中略)...
VariableCache ShmemVariableCache = NULL;
...(下略)...
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;初始化&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* backend/storage/ipc/shmem.c */
void 
InitShmemAllocation(void) 
{
  ~(中略)~
  ShmemVariableCache = (VariableCache)
		ShmemAlloc(sizeof(*ShmemVariableCache));
  memset(ShmemVariableCache, 0, sizeof(*ShmemVariableCache));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是Windows上的进程模型与Linux不同，Windows上并没有像&lt;code&gt;fork()&lt;/code&gt;这样能使子进程天生继承父进程资源的机制。因此PG在Windows上实现Postmaster进程向子进程传递全局变量&lt;code&gt;ShmemVariableCache&lt;/code&gt;时稍微绕了一下，将相关的地址dump到一个临时文件&amp;rdquo;pgsql_tmp&amp;rdquo;中，然后在调用&lt;code&gt;CreateProcess()&lt;/code&gt;创建子进程时将文件路径传入后再由子进程从文件中将地址恢复出来。这个过程就不在此处赘述了。&lt;/p&gt;

&lt;h3 id=&#34;oid的生成机制&#34;&gt;OID的生成机制&lt;/h3&gt;

&lt;p&gt;当一条元组被INSERT到表中的时候(也包括语法层面的&lt;code&gt;UPDATE&lt;/code&gt;语句，因为PG中的UPDATE本质上是将更新前的旧元组标记为无效并新增元组)。如果这是一张系统表，或是一张在创建时加了&lt;code&gt;WITH OIDS&lt;/code&gt;的用户数据表，那么在写入元组的时候，PG就会申请生成一个新的OID，并写到新元祖的OID字段中，这时就涉及到了OID的生成。&lt;/p&gt;

&lt;p&gt;OID的生成逻辑其实非常简单，其核心算法就是&amp;rdquo;把在保存共享内存的&lt;code&gt;VariableCacheData&lt;/code&gt;结构体中当前的&lt;code&gt;nextoid&lt;/code&gt;分配出去，之后让&lt;code&gt;nextoid&lt;/code&gt;自增一，同时让&lt;code&gt;oidcount&lt;/code&gt;减一&amp;rdquo;。当然，考虑到多个会话的并发，所以在执行上述算法的时候，会加上一把排他锁。&lt;/p&gt;

&lt;p&gt;上述核心算法的代码如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* backend/access/transam/varsup.c */
Oid
GetNewObjectId(void)
{
	Oid			result;

	if (RecoveryInProgress())
		elog(ERROR, &amp;quot;cannot assign OIDs during recovery&amp;quot;);

	LWLockAcquire(OidGenLock, LW_EXCLUSIVE);

	if (ShmemVariableCache-&amp;gt;nextOid &amp;lt; ((Oid) FirstNormalObjectId))
	{
		if (IsPostmasterEnvironment)
		{
			ShmemVariableCache-&amp;gt;nextOid = FirstNormalObjectId;
			ShmemVariableCache-&amp;gt;oidCount = 0;
		}
		else
		{
			if (ShmemVariableCache-&amp;gt;nextOid &amp;lt; ((Oid) FirstBootstrapObjectId))
			{
				ShmemVariableCache-&amp;gt;nextOid = FirstNormalObjectId;
				ShmemVariableCache-&amp;gt;oidCount = 0;
			}
		}
	}

	if (ShmemVariableCache-&amp;gt;oidCount == 0)
	{
		XLogPutNextOid(ShmemVariableCache-&amp;gt;nextOid + VAR_OID_PREFETCH);
		ShmemVariableCache-&amp;gt;oidCount = VAR_OID_PREFETCH;
	}

	result = ShmemVariableCache-&amp;gt;nextOid;

	(ShmemVariableCache-&amp;gt;nextOid)++;
	(ShmemVariableCache-&amp;gt;oidCount)--;

	LWLockRelease(OidGenLock);

	return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个简单的分配算法中有几个细节稍加说明一下:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;一开始的对&lt;code&gt;RecoveryInProgress()&lt;/code&gt;的调用，是判断当前实例是否处于恢复状态。我个人认为与其说它是在防护实例的恢复状态下不应存在的写操作，更不如说它是对&lt;strong&gt;Hot standby节点禁写&lt;/strong&gt;原则的又一层防护，毕竟Hot standby节点一直是运行于恢复态的。也就是说，Hot standby节点上的OID只能通过应用xlog来得到。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在之前的博文&lt;a href=&#34;https://xiaowing.github.io/post/20170903_howto_create_a_postgres_builtin_function/&#34;&gt;如何为PostgreSQL创建一个内置函数？&lt;/a&gt;我曾提到过&lt;strong&gt;16384&lt;/strong&gt;这个OID，事实上这也正是PG实例的Bootstrap过程结束后第一个留给用户的OID。因此，当OID递增耗尽回卷时，回卷后的第一个OID不是0，而是16384(也就是上述代码中的&lt;code&gt;FirstNormalObjectId&lt;/code&gt;)。这样可以确保PG实例内的所有&lt;strong&gt;内置数据库对象&lt;/strong&gt;的OID是绝对唯一的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;从上述代码可知，OID在每分配8192(即代码中的宏&lt;code&gt;VAR_OID_PREFETCH&lt;/code&gt;)个之后便会向xlog中记一条关于下一个OID分配区间的最大值。这个设计的意图会在下一章节介绍，此处暂时略过。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但是，由于OID只有四个字节，因此可以预见到它会有溢出的时刻，这时就会产生上文的所说的回卷逻辑。当OID回卷时，如何保证OID的相对唯一性(这里的“唯一性”在“什么是OID”这一章中有说明)呢？PG中实际上是在上述&lt;code&gt;GetNewObjectId()&lt;/code&gt;之外又封装了一个&lt;code&gt;GetNewOid()&lt;/code&gt;接口供PG代码使用，而在这个接口实现中，PG通过OID字段的索引实现了OID在一张表内的唯一性:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* backend/catalog/catalog.c */
Oid
GetNewOid(Relation relation)
{
	Oid			oidIndex;

	Assert(relation-&amp;gt;rd_rel-&amp;gt;relhasoids);

	if (IsBootstrapProcessingMode())
		return GetNewObjectId();

	oidIndex = RelationGetOidIndex(relation);

	if (!OidIsValid(oidIndex))
	{
		if (IsSystemRelation(relation))
			elog(WARNING, &amp;quot;generating possibly-non-unique OID for \&amp;quot;%s\&amp;quot;&amp;quot;,
				 RelationGetRelationName(relation));
		return GetNewObjectId();
	}

	return GetNewOidWithIndex(relation, oidIndex, ObjectIdAttributeNumber);
}

Oid
GetNewOidWithIndex(Relation relation, Oid indexId, AttrNumber oidcolumn)
{
	Oid			newOid;
	SnapshotData SnapshotDirty;
	SysScanDesc scan;
	ScanKeyData key;
	bool		collides;

	Assert(!IsBinaryUpgrade || RelationGetRelid(relation) != TypeRelationId);

	InitDirtySnapshot(SnapshotDirty);

	do
	{
		CHECK_FOR_INTERRUPTS();
		newOid = GetNewObjectId();
		ScanKeyInit(&amp;amp;key, oidcolumn, BTEqualStrategyNumber, F_OIDEQ,
					ObjectIdGetDatum(newOid));
		scan = systable_beginscan(relation, indexId, true, &amp;amp;SnapshotDirty, 1, &amp;amp;key);
		collides = HeapTupleIsValid(systable_getnext(scan));
		systable_endscan(scan);
	} while (collides);

	return newOid;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实它的思路也很简单: 如果这张表上没有基于OID字段的索引(理论上这种情况不会发生在系统表上，只会在用户的数据表上)，那么就直接调用上述核心算法的&lt;code&gt;GetNewObjectId()&lt;/code&gt;直接生成一个OID; 如果表上存在基于OID字段的索引，那么就反复尝试调用&lt;code&gt;GetNewObjectId()&lt;/code&gt;直到生成了一个这张表中未曾出现过的OID.此时生成的OID尽管可以保证在目标表中唯一，但很有可能它已经在别的表中也已经被使用了。这就是为什么在第一章中会说“&lt;strong&gt;在单个系统表内保存的OID一定可以保证唯一性，但是OID不能保证跨系统表之间的唯一性&lt;/strong&gt;”&lt;/p&gt;

&lt;h3 id=&#34;oid的持久化&#34;&gt;OID的持久化&lt;/h3&gt;

&lt;p&gt;搞清楚了OID的生成机制，很自然地就会产生一个想法: 既然每生成一个OID都会加锁，那么在上述的OID唯一性确保逻辑中如果尝试生成OID的次数过多，那就肯定会对并发的性能造成较大的伤害。但OID又是一个保存在共享内存中的数据，假设每次实例正常停机/重启或者异常Crash后恢复，OID就又要从初始的16384开始重新递增，结合上述生成逻辑中确保表内唯一性的试错循环，这对性能将是一个灾难!&lt;/p&gt;

&lt;p&gt;还好，PG的开发者们也想到了这一层, 而上述悲惨情况之所以不会发生的原因是因为PG中对于共享内存中的&lt;code&gt;newoid&lt;/code&gt;进行了持久化以确保实例重启后或者恢复后，还能够接着之前的&lt;code&gt;newoid&lt;/code&gt;生成，而不是从头再来一遍。&lt;/p&gt;

&lt;h3 id=&#34;持久化的时机&#34;&gt;持久化的时机&lt;/h3&gt;

&lt;p&gt;PG对于&lt;code&gt;newoid&lt;/code&gt;的持久化有两处：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;时机1: 上文的OID核心生成算法中所述——每分配完8192个OID就向xlog中插入一条记录，将下一个8192分配区间的最大值记录在xlog中。&lt;/p&gt;

&lt;p&gt;这里需要注意两点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;PG并不是每生成一个OID就向xlog中记录一次。理由是虽然这样很保险，但是记录xlog(就算只是写缓冲区)也是会对性能带来负面影响。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;写在xlog中的不是当前已分配区间的最大OID，而是下一个分配区间的最大OID。这样一来它可以保证在这个分配区间结束之前，所有已落入磁盘上的元组中，没有一个OID会大于这个写入xlog记录的OID(OID发生回卷除外&amp;hellip;&amp;hellip;)。这个设计意图在接下来介绍oid的恢复机制时会解说其用意。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;时机2: 生成Checkpoint时, 按下述逻辑将oid数据写入PG实例控制文件的检查点信息中.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void
CreateCheckPoint(int flags)
{
    ~(前略)~

    CheckPoint  checkPoint;
    MemSet(&amp;amp;checkPoint, 0, sizeof(checkPoint));
    checkPoint.time = (pg_time_t) time(NULL);

    ~(中略)~
        
    LWLockAcquire(OidGenLock, LW_SHARED);
    checkPoint.nextOid = ShmemVariableCache-&amp;gt;nextOid;
    if (!shutdown)
        checkPoint.nextOid += ShmemVariableCache-&amp;gt;oidCount;
    LWLockRelease(OidGenLock);

    ~(后略)~
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有意思的是，记录在Checkpoint时会根据Checkpoint的种类来执行不一样的记录行为:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果是SHUTDOWN检查点，则记录真实的下一个待分配的OID&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果不是SHUTDOWN检查点，则记录的其实和记录在xlog中的类似：当前分配区间的最大值。理由也是相仿的: 确保当前时间点已落入磁盘的元组中的已生成OID没有大于记录在checkpoint信息中的OID。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;两个持久化位置几乎殊途同归，持久化OID的策略几乎相同，这应该不是巧合:)&lt;/p&gt;

&lt;h3 id=&#34;恢复机制&#34;&gt;恢复机制&lt;/h3&gt;

&lt;p&gt;接下来从PG的恢复机制来揭晓上述持久化的残留疑问。&lt;/p&gt;

&lt;p&gt;PG从xlog恢复数据时一定是从最近的Checkpoint开始恢复，因为已实施的Checkpoint可以保证到这个Checkpoint为止的数据变更都已经落盘，且已利用xlog进行了一致性确认。所以PG只需要从这个最近的Checkpoint之后的xlog开始恢复即可。 所以，我们可以将全局的&lt;code&gt;VariableCacheData&lt;/code&gt;结构体中的&lt;code&gt;newOid&lt;/code&gt;字段的恢复分成以下几种情况：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;最近的Checkpoint之后没有记录NewOid的xlog记录&lt;/p&gt;

&lt;p&gt;这说明，实例Crash掉的时间点到最近的Checkpoint之间的时间间隔内，Oid的生成还在同一个8192的分配区间内。这时，即便Checkpoint之后还有一些新的数据写入，但是由于Checkpoint信息中持久化的是当前OID分配区间的最大值，因此可以确保Checkpoint之后分配的OID没有一个能够超过被持久化的那个OID。因此将全局的&lt;code&gt;VariableCacheData&lt;/code&gt;结构体中的&lt;code&gt;newOid&lt;/code&gt;字段恢复成当前分配期间的最大值，后续再生成新的OID也不用经历生成逻辑中确保表内唯一性的试错循环。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;最近的Checkpoint之后存在一条或多条记录NewOid的xlog记录&lt;/p&gt;

&lt;p&gt;这说明，实例Crash掉的时间点到最近的Checkpoint之间，OID的生成已经跨越了多个8192的分配区间。不过，由于xlog中记录NewOid时记录的都是每一个OID分配区间的最大值。与上一个情况相似，在逐个应用每一条记录NewOid的xlog日志记录后，最终会将将全局的&lt;code&gt;VariableCacheData&lt;/code&gt;结构体中的&lt;code&gt;newOid&lt;/code&gt;字段恢复成最后一个被使用的OID分配区间的最大值，仍然可以保证后续再生成新的OID也不用经历生成逻辑中确保表内唯一性的试错循环。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;当然，这两种情况都是建立在OID尚未发生回卷的前提下才有实际意义。如果已经发生了回卷，&lt;code&gt;newOid&lt;/code&gt;恢复的其实是一个较小的值，那么试错循环应该就不可避免了。&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;最后一种情况，最近的一个Checkpoint是SHUTDOWN检查点.&lt;/p&gt;

&lt;p&gt;这就意味着实例是被正常关闭重启的, 那么自然这个Checkpoint之后当然不会有任何新的xlog，也自然不会有任何磁盘上的数据更新。因此此时恢复的就是关机Checkpoint时真实的下一个待分配的OID。实例重启后从这个OID开始继续递增即可。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;由此可见，为了让PG实例启动/恢复后生成新的OID时能够尽可能减少保证唯一性的试错循环带来的负面影响。PG基于已有的恢复机制设计了一套比较合理又巧妙的持久化机制。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;上述恢复逻辑写在了&lt;code&gt;backend/access/transam/xlog.c&lt;/code&gt;的&lt;code&gt;
xlog_redo()&lt;/code&gt;函数和&lt;code&gt;StartupXlog()&lt;/code&gt;函数中，由于代码较多便不再贴出。&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;关于oid的一些思考&#34;&gt;关于OID的一些思考&lt;/h2&gt;

&lt;p&gt;关于OID本身的规格以及机制的介绍，基本上就到此结束了。OID的存在，实际上为PG内部的数据库对象实现了一个统一的抽象接口，进而PG可以实现其引以自豪的强大扩展能力。不过，站在&amp;rdquo;事后诸葛亮&amp;rdquo;的角度，我们还是可以看出OID设计中的一些遗憾。&lt;/p&gt;

&lt;p&gt;最大的遗憾恐怕是把OID设计得有点短了: 4个字节对于今天的大数据时代而言，很容易就耗尽了。而且在上文中也说过，一旦4个字节单调递增结束进入回卷阶段，那么将有可能会给PG的性能带来较大的负面影响。&lt;/p&gt;

&lt;p&gt;其实从上述OID的实现代码我们可以合理推测: 一开始的设计初衷中，OID肯定是希望被用来对PG中的所有数据库对象(包括用户数据表中的元组)进行唯一性标识的。佐证有两点：一来是OID的生成机制是简单递增; 二来是到&lt;a href=&#34;https://www.postgresql.org/docs/8.0/static/datatype-oid.html&#34;&gt;PG 8.0为止的手册&lt;/a&gt;里，用户&lt;code&gt;CREATE TABLE&lt;/code&gt;创建的数据表的默认行为是会给所有插入元组附上OID。当然，站在今天这个时间点上，唯一标识实例中所有数据库对象的重任肯定是没法儿交给OID来完成，因此OID就变成了系统表的专属“玩物”了。&lt;/p&gt;

&lt;p&gt;这个遗憾，恐怕可以比肩当年比尔盖茨的“内存有640KB就够了”的预言以及即将枯竭的IPv4地址资源。&lt;/p&gt;

&lt;p&gt;最后，再发散性地想一想: OID本身就是为了实现一个自增的唯一性ID。如果扩展到分布式系统架构下，PG的OID实现是否也可以套用呢？ 答案是肯定的，只需要把上述OID的实现机制中的两部分替换掉，我们就可以用完全相同的逻辑来实现一个适用于分布式架构下的高可用自增唯一性ID的生成服务。而那需要替换掉的两部分分别是:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;将&lt;strong&gt;共享内存&lt;/strong&gt;替换为一个高可用的内存数据库(比如&lt;strong&gt;Redis&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;将&lt;strong&gt;单机上的磁盘&lt;/strong&gt;替换为一个高可用的持久化存储组件(比如&lt;strong&gt;一个DBMS&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;昨天看到的这篇文章&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzI0MTk0NTY5MA==&amp;amp;mid=2247483753&amp;amp;idx=1&amp;amp;sn=ee92dd4b76550d333047256ed331b80a&amp;amp;chksm=e9029c5cde75154a56d76e8608d317ba49a073cd090db610992b2a0c35d2c649819635ae95e7&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=1208dDQ4MjIHoXZbH7xYZspA&amp;amp;pass_ticket=WMTOs1AURvSB6mWmq5lLAwcyI9EAIL%2BZRa4v13AlE82VEpLG7zmt4Y2JIEYG2J9E#rd&#34;&gt;基于 Redis 的序列号服务的设计&lt;/a&gt;则基本上验证了我的上述想法。难怪&lt;a href=&#34;https://coolshell.cn/haoel&#34;&gt;陈皓&lt;/a&gt;在不同场合都一直在劝诫程序员:&lt;strong&gt;&amp;ldquo;基础上的东西的变化少，基础上的东西一通百通&amp;rdquo;&lt;/strong&gt;。果然如是!&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[译文]Python为何会成为机器学习领域的主流语言</title>
      <link>https://xiaowing.github.io/post/20170913_python_and_machine_learning_cn/</link>
      <pubDate>Wed, 13 Sep 2017 21:37:02 +0800</pubDate>
      
      <guid>https://xiaowing.github.io/post/20170913_python_and_machine_learning_cn/</guid>
      <description>&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;pure-u-1-1&#34;&gt;
    &lt;div style=&#34;padding: 0 .2em&#34;&gt;
      &lt;img
        class=&#34;pure-img-responsive&#34;
        src=&#34;https://xiaowing.github.io/img/post/python-logo.png&#34;
        alt=&#34;Python Logo&#34;&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;


&lt;p&gt;最近因为在改PostgreSQL的相关的一些代码，因此在自学Perl语言。虽然和Python一样，它也是门解释型语言，然而这门语言真的是比较奇葩，因此无比地怀念Python.&lt;/p&gt;

&lt;p&gt;Python是我2015年自学的，虽然没用它做过什么正经的项目，但是小东西还是写了不少。只可惜自己终究还是修行不够，否则在目前这个被&amp;rdquo;人工智能&amp;rdquo;，“机器学习”等概念刷屏的年代，借助Python这门深受机器学习领域欢迎的语言，我说不定也能包装成一个年薪百万的大咖~&lt;/p&gt;

&lt;p&gt;不过，为什么机器学习领域会如此欢迎Python？之前在一个日文网站上看到一篇文章说这个事情，我觉得写得有点意思，所以就把它翻译了一下&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;python为何会成为机器学习领域的主流语言&#34;&gt;Python为何会成为机器学习领域的主流语言&lt;/h2&gt;

&lt;p&gt;原题: 機械学習でPythonが主流になっている必然的な理由とは&lt;/p&gt;

&lt;p&gt;作者: 株式会社キャパ&lt;/p&gt;

&lt;p&gt;链接: &lt;a href=&#34;http://www.capa.co.jp/archives/13875&#34;&gt;http://www.capa.co.jp/archives/13875&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0&#34;&gt;机器学习&lt;/a&gt;,或者说&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0&#34;&gt;深度学习&lt;/a&gt;的领域, Python正成为主流的编程语言。&lt;/p&gt;

&lt;p&gt;在海外，Python是作为一个用于编程教育的语言而慢慢普及开来的;但是在日本国内，Python则几乎没怎么受到过关注(&lt;em&gt;译注: 相对于Python，日本业界对于Ruby的关注度更高，大概因为Ruby是日本人发明的吧&lt;/em&gt;).那么，为什么在机器学习领域Python会成为主流呢？这其中有以下几个缘由:&lt;/p&gt;

&lt;h3 id=&#34;为什么选择了python-而不是c&#34;&gt;为什么选择了Python，而不是C++?&lt;/h3&gt;

&lt;p&gt;你知道解释型语言(通称:脚本语言)与编译型语言的差异吗？&lt;/p&gt;

&lt;p&gt;前者以Python以及Ruby为代表的语言，后者则因C语言或C++而广为人知。解释型语言是不管你将代码写到什么程度，随时都可以把写好的代码立刻运行起来;但是后者的编译型语言则必须遵循一定的编译手顺生成可执行文件之后，然后才能把它执行起来。编译型语言需要开发者在编译上花费一定的时间以及精力，但相对的，它的执行起来的性能是非常高速的。&lt;/p&gt;

&lt;p&gt;在机器学习领域，往往会涉及到大量的计算。理论上处理速度应该是越快越好，但为什么它选择了不是编译型语言的Python？其中有这么几点原因:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;“编码-运行”的周期可以变得更短&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在机器学习，或者深度学习领域，往往需要开发者写了代码以后立刻运行一下，根据运行结果进而修正相应的代码，之后再执行——这样的循环过程在实际开发中会再三反复。如果在这样的开发中选用了编译型语言，也就意味着在开发过程中实际上又要加入一个编译的过程，因此可以预见开发的生产性会下降。&lt;/p&gt;

&lt;p&gt;而且在编译型语言中，数据的&amp;rdquo;类型&amp;rdquo;是很受重视的，但是Python却是一个动态类型的语言，因此编码中根本无需声明数据的类型。对于同时有可能处理各种数据的机器学习而言，如果是用重视类型的编译型语言去一个个事先定义好数据的类型，写代码的时间应该会被拉长不少吧。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;拥有各种各样的涉及高速运算的程序库&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在Python中，拥有以&lt;code&gt;Numpy&lt;/code&gt;和&lt;code&gt;Scipy&lt;/code&gt;为代表的高速处理数值计算的程序库。因为有了这些库，尽管Python是解释型语言，但是可以借助它们的高速化而使人们不再对Python性能而感到担心。除此之外，还有&lt;code&gt;Matplotlib&lt;/code&gt;之类的绘图库，因此可以很简单地将机器学习的结果以图或表的形式展现出来。再借助&lt;code&gt;Django&lt;/code&gt;这个Web框架，就可以将机器学习的结果很方便地公开为一个Web服务，&lt;/p&gt;

&lt;p&gt;当然，Python中用于机器学习以及深度学习的各种程序库还在不断充实中。比如享誉业界的Google出品的&lt;code&gt;TensorFlow&lt;/code&gt;框架,以及&lt;code&gt;Caffe&lt;/code&gt;, &lt;code&gt;Scikit-learn&lt;/code&gt;, &lt;code&gt;Theano&lt;/code&gt;等等。Python中这些程序库/框架的充实度以及Python在机器学习中的流行度这两者之间，现在已经说不清到底是先有的鸡还是先有的蛋。总之，随着用户的增多，Python在机器学习方面的生态也的确会越变越好吧。&lt;/p&gt;

&lt;h3 id=&#34;r语言-与-python&#34;&gt;R语言 与 Python&lt;/h3&gt;

&lt;p&gt;R语言是数据科学家们用于进行数据统计的一门语言。而机器学习以及深度学习的知识领域其实与数据科学在很多方面是重合的。此外，在最初的阶段，R语言的程序库的性能普遍要更好。因此，一开始的时候普遍认为R语言会成为该领域的主流。&lt;/p&gt;

&lt;p&gt;但是，机器学习毕竟是需要通过软件开发人员来落地并实现的，比起只在数据科学家圈子中运用的R语言，对于软件开发人员而言，如果能用相对熟悉的Python语言来做，那当然会倾向于选择用Python来实现。因此，最终反而是Python中这方面的程序库变得更加充实起来。&lt;/p&gt;

&lt;h3 id=&#34;时势造就的python英雄&#34;&gt;时势造就的Python英雄&lt;/h3&gt;

&lt;p&gt;就结果而言，Python现今成了机器学习领域的主流语言。不过，这其实也谈不上是“必然”，只是经由时代选择而得到的一个结果而已。今后也许会发明一种专门面向机器学习领域的语言也说不定。只是目前还是暂时让Python的时代继续一段时间吧。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>如何为PostgreSQL创建一个内置函数？</title>
      <link>https://xiaowing.github.io/post/20170903_howto_create_a_postgres_builtin_function/</link>
      <pubDate>Sun, 03 Sep 2017 22:59:31 +0800</pubDate>
      
      <guid>https://xiaowing.github.io/post/20170903_howto_create_a_postgres_builtin_function/</guid>
      <description>&lt;p&gt;这篇文章我已经酝酿颇久了，诱因是因为&lt;a href=&#34;https://www.pingcap.com/index-zh&#34;&gt;PingCAP&lt;/a&gt;团队为了推广他们的&lt;strong&gt;TiDB&lt;/strong&gt;而在知乎专栏发了一篇文章《&lt;a href=&#34;https://zhuanlan.zhihu.com/p/24870620&#34;&gt;TiDB 增加 MySQL 内建函数&lt;/a&gt;》。受此文启发，我在网上搜索了一下&lt;strong&gt;PostgreSQL&lt;/strong&gt;(&lt;em&gt;以下略称&amp;rdquo;PG&amp;rdquo;&lt;/em&gt;)中定制内置函数(&lt;em&gt;Built-in Function&lt;/em&gt;)相关的文章，果然没有搜到什么像样的中文文章。其实为PG添加内置函数并不难，可能是相对于hacking它的SQL引擎或者存储引擎等等话题而言，加一个内置函数的逼格实在是太Low吧。不过TiDB这个诞生还没多久的数据库产品都知道通过先利用内置函数这个话题来由简入深地吸引广大开发者为它贡献代码，PG作为一个诞生了已有20年的开源数据库老大哥却没有一篇像样文章，也难怪PG的普及率不高了。&lt;/p&gt;

&lt;p&gt;以上就作为这篇分享的「意味づけ」吧&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;什么时候需要去增加一个内置函数&#34;&gt;什么时候需要去增加一个内置函数&lt;/h2&gt;

&lt;p&gt;其实在大多数情况下，鉴于PG提供了强大的SQL扩展能力，我们通常只需要掌握PG中&lt;a href=&#34;https://www.postgresql.org/docs/9.6/static/xfunc.html&#34;&gt;User Define Function(略称:UDF)&lt;/a&gt;就够了。不过内置函数的特性与UDF还是有些不同的，因此在一些特定场景下，我们可能会不得不采用内置函数的方式去定制一些函数接口。&lt;/p&gt;

&lt;p&gt;以下，我对比了一下内置函数和UDF的特性&amp;hellip;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;扩展灵活性&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;内置函数&lt;/em&gt;&lt;br/&gt;
不灵活。&lt;br/&gt;对内置函数的增/删/改都必须通过修改并重编PostgreSQL源码实现。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;User Defined Function&lt;/em&gt;&lt;br/&gt;
很灵活。&lt;br/&gt;通过&lt;code&gt;CREATE FUNCTION&lt;/code&gt;以及&lt;code&gt;DROP FUNCTION&lt;/code&gt;就可以实现UDF的增加与删除.且函数的具体实现可以通过多种语言(PL/pgsql,PL/python,PL/Perl等等)实现。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可见性&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;内置函数&lt;/em&gt;&lt;br/&gt;
内置函数默认在所有实例的所有Database中都可见&lt;/li&gt;
&lt;li&gt;&lt;em&gt;User Defined Function&lt;/em&gt;&lt;br/&gt;
由于UDF只是一个数据库对象。因此对于一个特定的UDF而言，一次CREATE FUNCTION只能使得它在该特定的Database中可见。若要在别的Database中也可见，需要在目标Database中也执行&lt;code&gt;CREATE FUNCTION&lt;/code&gt;语句&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;执行权限&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;内置函数&lt;/em&gt;&lt;br/&gt;
除非在内置函数的实现中做特定限制逻辑，否则内置函数默认对所有的数据库用户可执行&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;User Defined Function&lt;/em&gt;&lt;br/&gt;
默认只有创建了的该UDF数据库用户拥有执行权限，对于其他用户，需要通过&lt;code&gt;GRANT&lt;/code&gt;语句赋权&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于大部分PG用户而言，他们对SQL级别的函数的期待通常都是与具体业务数据紧密相关的(其中的大部分都是希望去实现一些存储过程),因此对于这部分用户而言，UDF已经足够(PG中“存储过程”这个概念已被融入UDF)。通常，只有在以下这几种场景下，我们才需要去实现一个内置函数:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;希望在SQL层面查询PG运行中的一些临时的内部状态(常见于做PG的商业发行版时为了为了满足一些特定需求)&lt;/li&gt;
&lt;li&gt;希望在SQL层面可以对PG的内部执行加以一些控制(常见于做PG的商业发行版时为了满足一些特定需求)&lt;/li&gt;
&lt;li&gt;纯粹只是想Hacking一下PG&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;增加内置函数的-三板斧&#34;&gt;增加内置函数的&amp;rdquo;三板斧&amp;rdquo;&lt;/h2&gt;

&lt;p&gt;其实为PG增添一个内置函数本身并不复杂，我总结下来也就三个步骤: &lt;strong&gt;实现函数&lt;/strong&gt;，&lt;strong&gt;声明函数&lt;/strong&gt; &amp;amp; &lt;strong&gt;注册函数&lt;/strong&gt;。下面我就用一个简单的例子来说明如何给PG增加一个内置函数。&lt;/p&gt;

&lt;h3 id=&#34;1-实现&#34;&gt;1. 实现&lt;/h3&gt;

&lt;p&gt;仿照《&lt;a href=&#34;https://book.douban.com/subject/26220250/&#34;&gt;PostgreSQL服务器编程&lt;/a&gt;》一书中的第8章实现一个最简单的函数:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;输入两个INTEGER的参数，返回一个表示两数相加及其结果的等式(TEXT)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;实现的代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;Datum
add_str(PG_FUNCTION_ARGS) {
    int arg_1, arg_2;
    char buf[128] = {0x00};
    char *result = NULL;

    if (PG_ARGISNULL(0) || PG_ARGISNULL(1)) {
        ereport(ERROR, 
            (errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED), 
             errmsg(&amp;quot;cannot specify NULL as the arguement.&amp;quot;)));
    }

    arg_1 = PG_GETARG_INT32(0);
    arg_2 = PG_GETARG_INT32(1);

    snprintf(buf, 128, &amp;quot;%d + %d = %d&amp;quot;, arg_1, arg_2, (arg_1 + arg_2));
    result = pstrdup(buf);

    PG_RETURN_TEXT_P(cstring_to_text(result));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里需要注意的是，与用C语言编写UDF一样，编写的函数必须是一个&lt;strong&gt;fmgr-compatible&lt;/strong&gt;的函数。即参数必须是&lt;code&gt;PG_FUNCTION_ARGS&lt;/code&gt;, 返回值必须是&lt;code&gt;Datum&lt;/code&gt;。这是由于PG中所有的SQL函数(含内置函数以及UDF)都被一个通用模块模块管理，该模块通过自己的一套机制去定位并执行SQL文中指定的SQL函数(SQL文中的函数调用机制，后面会另写博客分享)。&lt;/p&gt;

&lt;p&gt;上述函数可以实现在PG中的任何一个代码文件中(当然也可以新建一个源文件定于)。不过需要注意的是，必须确保这个源文件包含了&lt;code&gt;&amp;quot;funcapi.h&amp;quot;&lt;/code&gt;这个头文件。&lt;/p&gt;

&lt;p&gt;此外，这个例子只是为了示意，所以做了一个最简单的逻辑。在实际开发中，对于SQL函数，通常有一类需求是希望函数返回一个结果集。对于返回结果集的SQL函数，PG中称之为&lt;code&gt;SRF&lt;/code&gt;(Set Returning Functions). SRF的实现有一个固定范式，详细可以参见PG代码中的&lt;code&gt;src/include/funcapi.h&lt;/code&gt;的注释，内有关于这个范式的详细说明。&lt;/p&gt;

&lt;h3 id=&#34;2-声明&#34;&gt;2. 声明&lt;/h3&gt;

&lt;p&gt;PG中对于内置函数的声明有一个约定俗成的共通位置，即PG源码中的&lt;code&gt;src/include/utils/builtin.h&lt;/code&gt;。通常都是在该头文件中将实现的内置函数声明为一个extern函数以确保其对其他源码文件可见。&lt;/p&gt;

&lt;p&gt;不过，这也只是一个惯例而已，事实上，内置函数的声明位置并不一定限定与此。说白了，只要保证这个声明能让整个fmgr机制看到即可。&lt;/p&gt;

&lt;p&gt;函数声明本身全无特别，在本例中，声明就只是下面简单的一句话：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;extern Datum add_str(PG_FUNCTION_ARGS);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-注册&#34;&gt;3. 注册&lt;/h3&gt;

&lt;p&gt;Last but not least. 对于内置函数而言，光有实现和声明是不够的。与其他的数据库对象相仿，内置函数的元信息必须写入PG的数据字典中。而且由于系统表是数据库实例生来就有的对象，并没有一个CREATE文能帮它把元信息写入数据字典，因此这个步骤必须在源码中事先完成。这就是所谓的&lt;strong&gt;注册&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;与UDF一样，内置函数的元数据也是保存在系统表&lt;code&gt;pg_proc&lt;/code&gt;中的。而&lt;code&gt;pg_proc&lt;/code&gt;系统表在PG的数据库模板中初始状态下所具有的元数据元组是在&lt;code&gt;src/include/catalog/pg_proc.h&lt;/code&gt;中注册的。每个元组的注册格式如下:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;DATA(insert OID = 元组的唯一OID (  内置函数名 属性1 属性2&amp;hellip;&amp;hellip; ));&lt;br/&gt;
DESCR(内置函数的描述信息(使用半角双引号引起来));&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;为&lt;code&gt;pg_proc.h&lt;/code&gt;增加一个形如上文的元组时，有两个地方需要注意:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;OID必须保证全局唯一&lt;/p&gt;

&lt;p&gt;为&lt;code&gt;pg_proc.h&lt;/code&gt;增加元组时，必须分配一个&lt;strong&gt;9999&lt;/strong&gt;以内的唯一OID(在写下一个OID之前，可以先全文搜索一下PG源码确保其唯一性)&lt;/p&gt;

&lt;p&gt;至于为什么一定要将这个OID选在&lt;strong&gt;9999&lt;/strong&gt;以内，是因为PG源码的&lt;code&gt;src/include/access/transam.h&lt;/code&gt;对于Oid使用范围存在下述描述，且通过两个宏定义来限定:&lt;/p&gt;



&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;pure-u-1-1&#34;&gt;
    &lt;div style=&#34;padding: 0 .2em&#34;&gt;
      &lt;img
        class=&#34;pure-img-responsive&#34;
        src=&#34;https://xiaowing.github.io/img/post/20170903/about_oid.jpg&#34;
        alt=&#34;Object ID&#34;&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;


&lt;p&gt;在本例中，通过甄选，将&lt;code&gt;add_str&lt;/code&gt;内置函数在&lt;code&gt;pg_proc&lt;/code&gt;中元祖的OID选为&lt;strong&gt;5946&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;元组各个字段属性的写法&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pg_proc.h&lt;/code&gt;中内置函数的元数据的元组格式咋一看估计会让人懵掉。但实际上，这里的元组的各个属性(函数名已降的各字段)实际上对应的就是PostgreSQL手册中&lt;a href=&#34;https://www.postgresql.org/docs/9.6/static/catalog-pg-proc.html&#34;&gt;pg_proc系统表的各个字段&lt;/a&gt;。对照着这一章节的介绍以及参考&lt;code&gt;pg_proc.h&lt;/code&gt;中已有的内置函数的元组，就可知道该如何为新的内置函数增添元组。&lt;/p&gt;

&lt;p&gt;以下是在手册基础上，对pg_proc的元组各字段数据的写法做的一些补充说明:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;proisstrict&lt;/br&gt;
如果将此字段设置为&lt;code&gt;t&lt;/code&gt;, 只要通过SQL调用该函数时参数中有一个NULL，那么这个函数实际上不会被调用(即便函数实现中预备了对于NULL的处理)而是直接返回一个NULL。因此如果希望自己处理NULL参数，该字段不应为&lt;code&gt;t&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;proparallel&lt;/br&gt;
这个字段是 9.6 开始新加的字段。表示的是这个函数是否支持在并行查询的模式下并行执行。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;prorettype&lt;/br&gt;
返回值类型。这里需要填入的是返回值类型所对应的OID。这些OID可以在&lt;code&gt;src/include/catalog/pg_type.h&lt;/code&gt;中寻找。但需要注意的是，这里填的OID不要使用宏定义，直接填OID的数字。另外，结果集对应的OID是&lt;code&gt;2249&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;proargtypes和proallargtypes&lt;/br&gt;
这两个字段都需要以集合的形式写出参数类型OID集合。但写法上略有差别:&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;proargtypes的写法是&lt;code&gt;&amp;quot;OID1 OID2 ...&amp;quot;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;proallargtypes的写法是&lt;code&gt;{OID1 OID2 ...}&lt;/code&gt;。此外，如果返回值是一个结果集的话，填写此字段时，结果集中各个字段的类型也需要在&lt;code&gt;proallargtypes&lt;/code&gt;中严格按照结果集字段的顺序一一声明。在这里，结果集字段与输出参数可以视作等同效果.如果函数不包括任何输出参数且返回值不是结果集的话，这个字段可以直接声明为&lt;code&gt;_null_&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外，对于返回值是结果集的内置函数而言，也许要把结果集的每一个字段的信息反映在&lt;code&gt;proargmodes&lt;/code&gt;和&lt;code&gt;proargnames&lt;/code&gt;这两个属性中。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于本例的&lt;code&gt;add_str()&lt;/code&gt;函数比较简单，因此它在&lt;code&gt;pg_proc.h&lt;/code&gt;中对应的元组可写为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;DATA(insert OID = 5946 (  add_str PGNSP PGUID 12 1 0 0 0 f f f f f f s s 2 0 25 &amp;quot;23 23&amp;quot; _null_ _null_ _null_ _null_ _null_ add_str _null_ _null_ _null_ ));
DESCR(&amp;quot;add_str just for test&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到这里为止，向PG源码中增添新的内置函数的方法就已经介绍完毕了。但是在实践中，除了上述&amp;rdquo;三板斧&amp;rdquo;，还有一些坑最好也事先知道，以免在增添内置函数时走弯路.&lt;/p&gt;

&lt;h2 id=&#34;踩过的那些坑&#34;&gt;踩过的那些坑&lt;/h2&gt;

&lt;h3 id=&#34;坑1-内置函数的参数默认值&#34;&gt;坑1. 内置函数的参数默认值&lt;/h3&gt;

&lt;p&gt;PG中的SQL函数的参数是可以定义默认值的，然而C语言编写的函数是没有办法为其参数指定默认值的。这个Gap还是必须得从PG自己的机制着手。好消息是&lt;code&gt;pg_proc&lt;/code&gt;系统表中有一个字段叫做&lt;code&gt;proargdefaults&lt;/code&gt;,它看上去似乎可以用于解决参数默认值的问题; 但坏消息是，这个字段接受的是一个以字符串形式表示的&lt;code&gt;Express Tree&lt;/code&gt;，这几乎不是常人能通过人手能够写出来的。&lt;/p&gt;

&lt;p&gt;幸运的是，PG社区的大牛&lt;strong&gt;Tome Lane&lt;/strong&gt;在&lt;a href=&#34;https://www.postgresql.org/message-id/24148.1239060256@sss.pgh.pa.us&#34;&gt;2009年的一封邮件&lt;/a&gt;中指出了为内置函数设置默认值的正确姿势: 不要尝试在&lt;code&gt;pg_proc.h&lt;/code&gt;中通过元组的方式指定参数默认值——因为这种方式很&amp;rdquo;Ugly&amp;rdquo;——而是应该通过在&lt;code&gt;src/backend/catalog/system_views.sql&lt;/code&gt;中通过SQL文定义一个带默认值参数的函数去覆盖用C语言编写的SQL函数。比如，他在邮件中提到的内置函数&lt;code&gt;pg_start_backup()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE OR REPLACE FUNCTION
  pg_start_backup(label text, fast boolean DEFAULT false)
  RETURNS text LANGUAGE internal STRICT AS &#39;start_backup&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;换言之，可以先用C语言实现希望增加的内置函数的逻辑，再通过在&lt;code&gt;system_views.sql&lt;/code&gt;中创建SQL函数接口。当然，这个C语言函数仍然得遵循上文所说&lt;code&gt;fmgr-compatible&lt;/code&gt;范式.另外，由于&lt;code&gt;system_views.sql&lt;/code&gt;中定义的函数不是预先写入数据库模板中的，而是在&lt;code&gt;initdb&lt;/code&gt;创建实例的bootstrap过程中执行的，因此这样的函数的OID必然是在10000之后。&lt;/p&gt;

&lt;h3 id=&#34;坑2-pg-proc-h中新元组的生效时机&#34;&gt;坑2. pg_proc.h中新元组的生效时机&lt;/h3&gt;

&lt;p&gt;按照前文所述的&amp;rdquo;三板斧&amp;rdquo;来编写一个内置函数时，如果所用的PG源码所展开的路径是第一次执行编译还好，如果在所展开的路径下先前已经编译过至少一次的情况下，这时就会出现一个神奇的现象：重编后的二进制中可以看到新加的内置函数但无论如何就是没法走到。&lt;/p&gt;

&lt;p&gt;这是因为当我们给&lt;code&gt;pg_proc.h&lt;/code&gt;中增加新的内置函数对应的元组时，以下三个文件会在源码编译过程中基于&lt;code&gt;pg_proc.h&lt;/code&gt;的内容自动生成。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;src/backend/catalog/postgres.bki&lt;/br&gt;
src/backend/utils/fmgroids.h&lt;/br&gt;
src/backend/utils/fmgrtab.c&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这三个文件中生成的内容对于&lt;code&gt;pg_proc&lt;/code&gt;系统表中的初始化元组起重要作用。但是这三个文件只会在第一次编译时生成且并不会在&lt;code&gt;make clean&lt;/code&gt;时被清理掉。因此，如果是在一个已经执行过至少一次编译的源码环境中增加新的内置函数时，若要&amp;rdquo;三板斧&amp;rdquo;的最后一斧生效，必须在编译前执行下述命令:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$make maintainer-clean
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，这样一来原本生成的所有Makefile也将被清理掉，之后要编译这份代码的话，必须从&lt;code&gt;./configure&lt;/code&gt;重新开始。&lt;/p&gt;

&lt;h2 id=&#34;创建内置函数时最好知道的pg内部api&#34;&gt;创建内置函数时最好知道的PG内部API&lt;/h2&gt;

&lt;p&gt;用C语言为PG做扩展有一些通用的内部接口可供使用，这些接口也不限于内置函数。所以在我所知道的范围内列出一些内部接口，以作备忘:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.postgresql.org/docs/9.6/static/spi.html&#34;&gt;SPI系列函数&lt;/a&gt;&lt;/br&gt;
可以用于在内部执行SQL等等&lt;/li&gt;
&lt;li&gt;直接操作元组(Tuple)相关API

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CreateTemplateTupleDesc()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TupleDescInitEntry()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BlessTupleDesc()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;heap_from_tuple()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;用于查询执行时当前会话状态判断的实用函数

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;superuser()&lt;/code&gt;&lt;/br&gt;
判断当前用户是否是DB的超级用户&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IsTransaction()&lt;/code&gt;&lt;/br&gt;
判断当前语句是否在一个显式事务块中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IsInParallelMode()&lt;/code&gt;&lt;/br&gt;
判断当前是否在并行执行模式中&lt;/li&gt;
&lt;li&gt;全局变量 &lt;code&gt;XactReadOnly&lt;/code&gt;&lt;/br&gt;
判断当前会话是否是只读模式&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;

&lt;p&gt;以上就是给PG添加内置函数的方法的一个小结，也是我最近一段时间一直在折腾PG的SQL函数所做的一点积累, 希望能够为有类似需求的人提供一些帮助。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[译文]GO语言是面向对象的吗？</title>
      <link>https://xiaowing.github.io/post/20170816_is_go_object_oriented_cn/</link>
      <pubDate>Wed, 16 Aug 2017 21:48:52 +0800</pubDate>
      
      <guid>https://xiaowing.github.io/post/20170816_is_go_object_oriented_cn/</guid>
      <description>&lt;p&gt;周一在微信上收到了&lt;a href=&#34;http://www.weixinyidu.com/a_277786&#34;&gt;Go中国&lt;/a&gt;公众号推送的一篇文章 &lt;a href=&#34;https://flaviocopes.com/golang-is-go-object-oriented/&#34;&gt;Is GO object oriented&lt;/a&gt; ,读完以后感觉观点还是很有意思的，与我的所见有很多相似之处，所以就饶有兴趣地把它翻译成中文，也算是作为&amp;rdquo;友军&amp;rdquo;的一点贡献吧&amp;hellip;&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;go语言是面向对象的吗&#34;&gt;GO语言是面向对象的吗？&lt;/h2&gt;

&lt;p&gt;原题: IS GO OBJECT ORIENTED?&lt;/p&gt;

&lt;p&gt;作者: Flavio Copes&lt;/p&gt;

&lt;p&gt;链接: &lt;a href=&#34;https://flaviocopes.com/golang-is-go-object-oriented/&#34;&gt;https://flaviocopes.com/golang-is-go-object-oriented/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;有时候我会读到文章宣称&amp;rdquo;GO语言是面向对象的语言&amp;rdquo;，有时候我又会读到一篇持相反观点的文章宣称&amp;rdquo;GO语言无法做到面向对象编程因为它根本没有&amp;rsquo;类&amp;rsquo;&amp;ldquo;.&lt;/p&gt;

&lt;p&gt;有鉴于此，我写了这篇文章来阐述这个话题: &lt;strong&gt;GO语言到底是不是面向对象的语言&lt;/strong&gt;？&lt;/p&gt;

&lt;p&gt;如果你习惯了从某种特定编程语言的视角来思考问题，那么在这个话题上，你可能会由于自己所惯于使用的语言不同而得出截然相反的答案。比如说，如果你之前习惯了使用C语言，那么很显然GO语言拥有太多面向对象的特性；但是如果你之前习惯了使用Java，那么GO语言看起来就不那么&amp;rdquo;面向对象&amp;rdquo;了。&lt;/p&gt;

&lt;p&gt;因此关于这个话题，你首先要做的是摒弃其他语言带给你的先入为主的观念并学会用GO语言的思维模式来思考。&lt;/p&gt;

&lt;p&gt;然后我就可以给出我的答案了: YES. GO语言是一门面向对象的语言, 而且是以一种很清爽的方式实现了面向对象.&lt;/p&gt;

&lt;p&gt;在&lt;a href=&#34;https://golang.org/doc/faq#Is_Go_an_object-oriented_language&#34;&gt;GO语言官方文档的FAQ&lt;/a&gt;中也表述过下述内容&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Is Go an object-oriented language?&lt;/p&gt;

&lt;p&gt;Yes and no. Although Go has types and methods and
allows an object-oriented style of programming, there
is no type hierarchy. The concept of “interface” in Go
provides a different approach that we believe is easy
to use and in some ways more general. There are also
ways to embed types in other types to provide something
analogous—but not identical—to subclassing. Moreover,
methods in Go are more general than in C++ or Java:
they can be defined for any sort of data, even built-in
types such as plain, “unboxed” integers. They are not
restricted to structs (classes).
Also, the lack of a type hierarchy makes “objects” in
Go feel much more lightweight than in languages such as
C++ or Java.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;集众家所长&#34;&gt;集众家所长&lt;/h3&gt;

&lt;p&gt;GO语言从&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E8%BF%87%E7%A8%8B%E5%BC%8F%E7%BC%96%E7%A8%8B&#34;&gt;过程式编程语言&lt;/a&gt;, &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B8%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80&#34;&gt;函数式编程语言&lt;/a&gt;以及&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1&#34;&gt;面向对象编程语言&lt;/a&gt;中都汲取了一些概念并将它们组装在一起后，将那些剩余的概念舍弃从而创造了一门极具特性但又十分地道的编程语言。&lt;/p&gt;

&lt;h3 id=&#34;要结构体-不要类&#34;&gt;要结构体,不要类&lt;/h3&gt;

&lt;p&gt;GO语言中并没有传统面向对象编程语言中的&amp;rdquo;类&amp;rdquo;(&lt;code&gt;class&lt;/code&gt;)的概念，取而代之的是使用了&amp;rdquo;结构体&amp;rdquo;(&lt;code&gt;struct&lt;/code&gt;)。但是GO语言的结构体可比C语言中的同名前辈要强大得多。在GO语言中,结构体以及结构体的方法(&lt;code&gt;method&lt;/code&gt;)发挥了与传统意义上的&amp;rdquo;类&amp;rdquo;相同的作用，同时在概念上又清晰分明——结构体只负责管理状态，不管理行为;而结构体的方法则负责定义结构体的行为，比如说允许他们更改状态.&lt;/p&gt;

&lt;h3 id=&#34;封装的奥义&#34;&gt;封装的奥义&lt;/h3&gt;

&lt;p&gt;我认为GO语言中最好的一个特性就是，直接明了地通过字段名, 方法名以及函数名的首字母大写来保证它们的访问可见性为&lt;strong&gt;public&lt;/strong&gt;。其他的那些以小写字母开头的字段等则默认为包(&lt;code&gt;package&lt;/code&gt;)内私有(private)并且无法被导出至包外。这个特性使得开发者们一眼就可以看出来哪些字段/方法/属性是public的，哪些是private的。另外，由于GO语言中没有&lt;strong&gt;继承&lt;/strong&gt;这一概念，所以GO语言中的访问修饰也就根本没有&lt;code&gt;protected&lt;/code&gt;的概念.&lt;/p&gt;

&lt;h3 id=&#34;无继承&#34;&gt;无继承&lt;/h3&gt;

&lt;p&gt;GO语言中没有&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%BB%A7%E6%89%BF_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)&#34;&gt;继承&lt;/a&gt;,这一点在&lt;a href=&#34;https://golang.org/doc/faq#Why_is_there_no_type_inheritance&#34;&gt;GO语言官方文档的FAQ&lt;/a&gt;也有明确说明:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Object-oriented programming, at least in the best-known
languages, involves too much discussion of the
relationships between types, relationships that often
could be derived automatically. Go takes a different
approach.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;用组合代替继承&#34;&gt;用组合代替继承&lt;/h3&gt;

&lt;p&gt;程序设计理念中最广为认知的准则之一即是 &lt;a href=&#34;https://en.wikipedia.org/wiki/Composition_over_inheritance&#34;&gt;用组合代替继承&lt;/a&gt;。这一准则在&lt;a href=&#34;https://en.wikipedia.org/wiki/Design_Patterns&#34;&gt;四人帮&lt;/a&gt;的那本极富盛名的《设计模式》也屡有提及。而在GO语言中，这一准则被发挥得淋漓尽致。&lt;/p&gt;

&lt;p&gt;当我们在定义一个结构体时，我们可以追加类型为另一个结构体的匿名字段。这样一来，我们定义的这个结构体也就同时拥有了另一个结构体的所有字段以及方法。这种技法被称之为&lt;strong&gt;Struct Embedding&lt;/strong&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

type Dog struct {
	Animal
}
type Animal struct {
	Age int
}

func (a *Animal) Move() {
	fmt.Println(&amp;quot;Animal moved&amp;quot;)
}
func (a *Animal) SayAge() {
	fmt.Printf(&amp;quot;Animal age: %d\n&amp;quot;, a.Age)
}
func main() {
	d := Dog{}
	d.Age = 3
	d.Move()
	d.SayAge()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://play.golang.org/p/IxMoeByWp5&#34;&gt;执行结果&lt;/a&gt; (需要科学上网)&lt;/p&gt;

&lt;h3 id=&#34;接口&#34;&gt;接口&lt;/h3&gt;

&lt;p&gt;忘记Java或PHP风格的接口概念吧！GO语言中的接口是截然不同的，而其中最关键的一个特性即是: &lt;strong&gt;接口是隐式实现的&lt;/strong&gt;——不需要在定义类型时去显式声明一下类型实现了哪些接口。&lt;/p&gt;

&lt;p&gt;还是摘抄自&lt;a href=&#34;https://golang.org/doc/faq#Why_is_there_no_type_inheritance&#34;&gt;GO语言官方文档的FAQ&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Rather than requiring the programmer to declare ahead
of time that two types are related, in Go a type
automatically satisfies any interface that specifies a
subset of its methods.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通常，接口的定义都很短，甚至有可能至包含一个方法声明。在地道的GO语言实践中，你不应该看到一个接口拥有长长的方法列表。&lt;/p&gt;

&lt;p&gt;借助这样的接口就可以很优雅地实现&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%9E%8B_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)&#34;&gt;多态&lt;/a&gt;: 一个方法如果接受某一个接口，那么就意味着这个方法接受了任何实现了该接口的对象.&lt;/p&gt;

&lt;h3 id=&#34;方法&#34;&gt;方法&lt;/h3&gt;

&lt;p&gt;GO语言中的类型往往都拥有方法，但是这些方法的定义是独立于类型定义而存在的。GO语言在语法层面通过一个类似Javascript中prototype方法的特性来实现了这种定义的独立性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Person(first, last) {
    this.firstName = first;
    this.lastName = last;
}
Person.prototype.name = function() {
    return this.firstName + &amp;quot; &amp;quot; + this.lastName;
};
p = new Person(&amp;quot;Flavio&amp;quot;, &amp;quot;Copes&amp;quot;)
p.name() // Flavio Copes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在GO语言中，代码应该写成这样:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)
type Person struct {
	firstName string
	lastName  string
}
func (p Person) name() string {
	return p.firstName + &amp;quot; &amp;quot; + p.lastName
}
func main() {
	p := Person{&amp;quot;Flavio&amp;quot;, &amp;quot;Copes&amp;quot;}
	fmt.Println(p.name())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;关联方法与类型&#34;&gt;关联方法与类型&lt;/h3&gt;

&lt;p&gt;方法可以被关联至任何类型,甚至是&amp;rdquo;曲线救国&amp;rdquo;式地关联到GO语言中的基础类型。由于方法只能被关联至在同一个包中定义的类型,所以我们无法直接&amp;rdquo;扩展&amp;rdquo;基础类型。但事实上，我们可以通过对基础数据类型定义别名从而达到扩展的目的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

type Amount int

func (a *Amount) Add(add Amount) {
	*a += add
}

func main() {
	var a Amount
	a = 1
	a.Add(2)
	fmt.Println(a)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://play.golang.org/p/ONlUmue1jA&#34;&gt;显示结果&lt;/a&gt; (需要科学上网)&lt;/p&gt;

&lt;h3 id=&#34;函数&#34;&gt;函数&lt;/h3&gt;

&lt;p&gt;让我们回想一下传统的面向对象编程语言吧，比如Java。想想看你曾经定义过多少次包含的全是static方法的名为&amp;rdquo;Utils&amp;rdquo;的类?&lt;/p&gt;

&lt;p&gt;这样的现象来源与传统的面向对象变成语言中的一个观念: &lt;strong&gt;一切皆是对象&lt;/strong&gt;，因此函数定义必须放在一个类里面。所幸的是，这种现象不会发生在GO语言中，因为GO语言有真正的&amp;rdquo;函数&amp;rdquo;这一概念。在真实世界中，并非所有事物都必须是一个对象。&amp;rdquo;类&amp;rdquo;和&amp;rdquo;对象&amp;rdquo;的概念很有用，但也不能到处都用。&lt;/p&gt;

&lt;p&gt;在GO语言中，并非所有东西都是对象(若严格从技术角度而言，GO语言没有东西是对象。但通常人们会将一个类型的实例或者变量称之为&amp;rdquo;对象&amp;rdquo;),方法仅仅是指那些被关联至某一类型的函数。但GO语言同时又允许函数脱离于对象而独立存在,就如同C语言的函数一样。&lt;/p&gt;

&lt;p&gt;所以，GO语言既允许方法存在，也允许函数存在。而且，函数是第一优先的(函数类型可用作定义结构体字段,函数可作为参数传递至其他函数，函数也可作为返回值被函数或方法返回)。&lt;/p&gt;

&lt;h3 id=&#34;大道至简&#34;&gt;大道至简&lt;/h3&gt;

&lt;p&gt;综上所述，GO语言对于面向对象的实现非常灵活且直接。不用再纠结于类和继承，你可以减少对源码模板文件的依赖，而且不用再一点一点地推敲类与类之间的理想层级结构，从此你只需根据需求自由地对类型进行组合或拆解即可。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>主线程等待子线程结束的各语言实现</title>
      <link>https://xiaowing.github.io/post/20170805_main_thread_sync_with_others/</link>
      <pubDate>Sat, 05 Aug 2017 22:18:06 +0800</pubDate>
      
      <guid>https://xiaowing.github.io/post/20170805_main_thread_sync_with_others/</guid>
      <description>&lt;p&gt;在涉及到并发编程的情况下，经常性地会碰到一种场景:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;由一个线程开启了多个线程并发执行多个任务，之后由该线程(so called &amp;ldquo;主线程&amp;rdquo;)等待多个线程都结束后汇总结果.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这种场景下，主线程在其创建的子线程执行期间内需要阻塞，直到其他子线程都执行完毕。由于这类场景已经在不同语言的开发中遇到多次，所以汇总一下这些语言的常用实现方法，以后查起来也方便~&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;C语言实现
C语言在操作多线程方便由于缺乏一个统一的标准库，所以在Linux和Windows上各有各的实现方法:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Linux版实现&lt;/p&gt;

&lt;p&gt;在Linux上的实现，主要是基于POSIX thread库进行实现，实例代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;pthread.h&amp;gt;

int main(void) {
    int i;
    pthread_t threads[THREAD_NUM];

    pthread_setconcurrency(THREAD_NUM);

    for (i = 0; i &amp;lt; THREAD_NUM; i++){
        /* 将需要执行的job的函数地址func传入新建的子线程 */
        pthread_create(&amp;amp;threads[i], NULL, func, NULL);
    }

    for(i = 0; i &amp;lt; THREAD_NUM; i++){
        pthread_join(handles[i], NULL);
    }

    /* 后续的处理逻辑略... */
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Windows版实现&lt;/p&gt;

&lt;p&gt;在Windows版上的实现中，主要是基于Windows API实现。由于Windows本身就和Linux就是风格迥异，因此在阻塞主线程的API设计上，也是略有不同：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;Windows.h&amp;gt;

int main(void) {
    int i;
    HANDLE handles[THREAD_NUM];

    for (i = 0; i &amp;lt; THREAD_NUM; i++){
        /* 将需要执行的job的函数地址func传入新建的子线程 */
        handles[i] = CreateThread(NULL, 0, func, NULL, 0, NULL);
    }

    WaitForMultipleObjects(THREAD_NUM, handles, TRUE, INFINITE);

    /* 后续的处理逻辑略... */
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是，Windows API的&lt;code&gt;WaitForMultipleObjects()&lt;/code&gt;其实不仅仅是为多线程场景服务的，它可以用与多种内核句柄，如&lt;code&gt;Event&lt;/code&gt;，&lt;code&gt;Mutex&lt;/code&gt;，&lt;code&gt;Process&lt;/code&gt;，&lt;code&gt;Thread&lt;/code&gt;，&lt;code&gt;Semaphore&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Python3的实现&lt;/p&gt;

&lt;p&gt;Python3的实现形式与C语言的Linux版类似: 当子线程仍活着的时候，则通过类似Join()方法之类的API来阻塞当前的主线程。代码示例如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from threading import Thread

if __name__ == &#39;__main__&#39;:
    thread_list = []

    for x range (0, THREAD_NUM):
        # 将需要执行的job的函数和参数传入新建的子线程
        t = Thread(target=job_func, args=(job_args,))
        t.start()
        thread_list.append(t)
        
    for element in thread_list:
        if element.is_alive():
            element.join()    # 通过join方法阻塞主线程
    else:
        # 后续的处理逻辑略...
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Golang的实现&lt;/p&gt;

&lt;p&gt;由于Golang的语言特色，并发通过goroutine来实现。通常情况下，各个goroutine根本不需要知道彼此的存在。因此对于这个场景的实现方式，与之前的那些语言都有所不同.代码示例如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main
    
import (
    &amp;quot;sync&amp;quot;
)

func main() {
    var wait sync.WaitGroup
    wait.Add(ROUTINE_NUM)

    for i := 0; i &amp;lt; ROUTINE_NUM; i++ {
        go func() {
            defer wait.Done()

            //Goroutine所要执行的Job逻辑略...
        }()
    }
    wait.Wait()

    // 后续的处理逻辑略...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在之前的语言中，主线程在起了多个子线程后，不管用什么API阻塞，主线程或多或少还需要关注一下子线程(句柄等)，但是在Golang中，主协程不需要关注各个携程。主协程等待其他协程的这个场景，完全基于Workgroup就可以简单实现。&lt;/p&gt;

&lt;p&gt;真不愧是一门面向并发的语言:)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后需要说明的是，虽然本文描述的这个场景叫做&amp;rdquo;主线程等待子线程&amp;rdquo;。但实际上，无论是线程模型还是协程模型，线程与线程之间(协程与协程之间)都是平等的。毕竟只有在多进程模型下，被fork出的子进程会继承父进程的大部分数据(如打开的文件描述符)，完全相当于父进程的副本的形式。而这样的关系在线程模型(或协程模型)中并不存在，此处的说法完全只是遵循某种不成文的惯例，算是&amp;rdquo;&lt;strong&gt;阀值&lt;/strong&gt;&amp;ldquo;之于&amp;rdquo;&lt;strong&gt;阈值&lt;/strong&gt;&amp;ldquo;这样的错误吧。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C语言程序通过函数指针调用Go函数的方法</title>
      <link>https://xiaowing.github.io/post/howto_call_a_go_func_via_funcpoint_from_cside/</link>
      <pubDate>Sun, 30 Jul 2017 16:16:03 +0800</pubDate>
      
      <guid>https://xiaowing.github.io/post/howto_call_a_go_func_via_funcpoint_from_cside/</guid>
      <description>&lt;p&gt;在github上关于cgo的wiki中，有一&lt;a href=&#34;https://github.com/golang/go/wiki/cgo#function-pointer-callbacks&#34;&gt;章节&lt;/a&gt;专门介绍了如何利用cgo技术通过函数指针调用Golang的函数实现. 不过，仔细观察这个章节的代码示例可以发现，它所要解决的其实是以下的场景:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在Golang中想要调用一个已有的C语言函数，但是该C语言函数要求一个函数指针作为参数时应该怎么办？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果将这个场景稍微改变一下，改成以下场景，对应的解法又该是什么？&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在一个C语言实现的已有系统中，对于一个要求函数指针的函数，如何传入一个Golang实现的回调函数以实现“用Golang扩展C语言系统”的目的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我基于wiki中已有的代码简单探索了一下方法，结果分享如下：&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;试验代码的准备&#34;&gt;试验代码的准备&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先，需要一个声明了函数指针类型的头文件(也就是C语言和Golang的接口)。这里流用了上述wiki中的示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* clib.h */

#ifndef CLIBRARY_H
#define CLIBRARY_H
typedef int (*callback_fcn)(int);
#endif
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;接下来是C语言程序中调用上述函数指针的入口函数.这个文件也是从wiki中流用的.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* clib.c */
#include &amp;lt;stdio.h&amp;gt;
#include &amp;quot;clib.h&amp;quot;

void some_c_func(callback_fcn callback)
{
    int arg = 2;
    printf(&amp;quot;C.some_c_func(): calling callback with arg = %d\n&amp;quot;, arg);
    int response = callback(2);
    printf(&amp;quot;C.some_c_func(): callback responded with %d\n&amp;quot;, response);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个程序中，没有定义callback_fcn这个函数指针的具体实现。这个实现将交给下面的Golang进行&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在Golang中实现回调函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* goprog.go */
package main        /* 包名必须是main */

/*
#cgo CFLAGS: -I {clib.h的路径(目录)}

#include &amp;quot;clib.h&amp;quot;

int callOnMeGo_cgo(int in); // Forward declaration.
*/
import &amp;quot;C&amp;quot;

import &amp;quot;fmt&amp;quot;

//export callOnMeGo
func callOnMeGo(in int) int {
    fmt.Printf(&amp;quot;Go.callOnMeGo(): called with arg = %d\n&amp;quot;, in)
    return in + 1
}

func main() {}        /* 必须定义一个空的main函数 */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个文件基于Wiki中的示例稍微改了一点，把main函数的实现给去掉了，但保留了一个空的main函数。 此外，不论这个文件在哪里创建，它的package被定义为main。相关的理由如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;cgo在将go源代码编译成shared-library的过程中，只会将package声明为main的源代码纳入编译，其余的文件都会被忽略&lt;/li&gt;
&lt;li&gt;由于参与编译的源代码的package都为main，根据Golang编译器的规则，则必须有一个main()函数，否则编译不过&lt;/li&gt;
&lt;li&gt;根据第2点，如果参与编译的源码中有超过一个main函数，编译器也会报错。
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意: 这里有一个坑：如果将带main函数的.c文件和这些go文件放在一起，然后启动golang编译器编译器编译，也会报错，说main函数数量过多。不知golang编译器为什么要去识别C语言的main函数&amp;hellip;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;这样一来，回调函数的实现本体就已经完成了。但是如果仅仅如此，是无法实现C语言调用这个函数的，这是因为两种语言的类型不一致，因此实际上上述回调函数的接口与函数指针的声明仍然不一样，所以需要一个&lt;strong&gt;Adapter&lt;/strong&gt;。在cgo中，这样的&lt;strong&gt;Adapter&lt;/strong&gt;被称为&amp;rdquo;&lt;code&gt;Gateway Function&lt;/code&gt;&amp;rdquo;. 直接搬用Wiki中的代码即可：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* cfuncs.go */
package main

/*

#include &amp;lt;stdio.h&amp;gt;

// The gateway function
int callOnMeGo_cgo(int in)
{
    printf(&amp;quot;C.callOnMeGo_cgo(): called with arg = %d\n&amp;quot;, in);
    int callOnMeGo(int);
    return callOnMeGo(in);
}
*/
import &amp;quot;C&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有意思的是，这个Gateway Function实际上是一个实现在go源码注释中的C语言函数，它的声明与函数指针一致。但是它实际封装的却又是一个golang函数.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;构建过程&#34;&gt;构建过程&lt;/h2&gt;

&lt;p&gt;到这时为止，所需的代码就算是写完了，接下来需要把程序构建并运行起来：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;用golang编译器构建共享库:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$go build -buildmode=c-shared -o libgoprog.so {所有参与编译的go源码}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;值得注意的是，&lt;code&gt;-buildmode=c-shared&lt;/code&gt; 是直到&lt;strong&gt;golang1.5&lt;/strong&gt;开始才有的选项，且该选项到目前为止(golang1.8)只支持linux平台，&lt;strong&gt;不支持windows和Mac OS&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;编译成功后，会生成两个文件： 一个是库文件(&lt;code&gt;libgoprog.so&lt;/code&gt;), 另一个是该库文件对应的头文件(&lt;code&gt;libgoprog.h&lt;/code&gt;).这个头文件的片段如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* libgoprog.h */

#include &amp;quot;clib.h&amp;quot;
int callOnMeGo_cgo(int in);  /* &amp;lt;- 在go源码中定义的Gateway Function */

...(中略)...

extern GoInt callOnMeGo(GoInt p0);   
...(下略)...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时如果用&lt;code&gt;file&lt;/code&gt;命令看一下生成的.so文件，应该是类似以下的结果：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;libgoprog.so: ELF 64-bit LSB  shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=f49bbe5d2d38c184574b65ed11f55e84c1ad19e3, not stripped&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;同时，如果用&lt;code&gt;nm&lt;/code&gt;查看这个.so文件的导出符号，就可以看到callOnMeGo和callOnMeGo_cgo这两个符号了&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;由于上一步骤生成了这个头文件，所以此处还需要修改一下之前的 clib.c 文件，把这个头文件给 #include 进去，从而就可在clib.c中看见那个Gateway Function的声明了，而且此时就可以为clib.c文件补上 main() 函数的实现了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* clib.c 完整版 */

#include &amp;lt;stdio.h&amp;gt;
#include &amp;quot;clib.h&amp;quot;
#include &amp;quot;libgoprog.h&amp;quot;    /* 追加头文件引用 */

void some_c_func(callback_fcn callback)
{
    int arg = 2;
    printf(&amp;quot;C.some_c_func(): calling callback with arg = %d\n&amp;quot;, arg);
    int response = callback(2);
    printf(&amp;quot;C.some_c_func(): callback responded with %d\n&amp;quot;, response);
}

int main(void) {        /* 追加main()函数实现 */
    some_c_func(callOnMeGo_cgo);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编译这个C程序&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;$gcc clib.c -I{clib.h的目录路径} -I{生成的libgoprog.h的目录路径} -L{libgoprog.so的目录路径} -lgoprog -o clibmain
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一切正常的话，就可以正常生成可执行文件clibmain了。之后再将先前生成的libgoprog.so 放置到链接器可找到的路径下，执行该程序就可得到下述结果了:&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;



&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;pure-u-1-1&#34;&gt;
    &lt;div style=&#34;padding: 0 .2em&#34;&gt;
      &lt;img
        class=&#34;pure-img-responsive&#34;
        src=&#34;https://xiaowing.github.io/img/post/20170730/c-calls-go-output.jpg&#34;
        alt=&#34;通过函数指针调用golang函数的输出&#34;&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;


&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;综上，使用golang自带的cgo技术，可以方便地打通C语言和Golang语言。但目前，Go语言编译动态库还只能在Linux平台上实现，需要注意。&lt;/p&gt;

&lt;p&gt;另外，考虑到两种语言在数据类型上还是存在较多差异(事实上，编译生成共享库时附带生成的头文件中就定义了大量golang类型到C语言的映射)，因此，如果真的要编写程序在C语言中调用Go，其实有相当一部分工作量应该会花在数据类型转换上。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>一见如故的Go语言</title>
      <link>https://xiaowing.github.io/post/why_i_love_the_go_programming_language/</link>
      <pubDate>Sun, 30 Jul 2017 14:17:37 +0800</pubDate>
      
      <guid>https://xiaowing.github.io/post/why_i_love_the_go_programming_language/</guid>
      <description>&lt;p&gt;从去年接触Go语言(以后简称&amp;rdquo;Golang&amp;rdquo;)到现在，已经有1年的时间了。感觉随着使用经验的积累，越发地喜爱这么编程语言。作为一个以C, C#语言出道，并自学了Java, Python, Golang的无证程序员，使用 了一段时间Go语言后，最明显的感觉就是：“这正式我所期盼的语言”。特别是写多了C语言代码，虽然感叹于C语言在语言上的简洁与性能上的高效，但是对于现实中C语言在开发方面的低效也总是吐槽不断。遭遇了Go语言之后，认为这门语言是C语言的最好传人(不要提C++)。&lt;/p&gt;



&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;pure-u-1-1&#34;&gt;
    &lt;div style=&#34;padding: 0 .2em&#34;&gt;
      &lt;img
        class=&#34;pure-img-responsive&#34;
        src=&#34;https://xiaowing.github.io/img/post/golang-gopher-100.jpg&#34;
        alt=&#34;Gopher&#34;&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;


&lt;p&gt;以下分享一些我认为Golang做的比较值得推崇的地方：&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Golang是直接编译成本地机器码，这就决定了其二进制是无法跨平台的。但是得益于Golang社区在各个平台上开发的编译器都很给力，而且提供了共通且强大的标准库，使得对于Go语言的开发者而言事实上不需要去太关注跨平台的问题(当然，可能会需要在特定平台上额外加一些分支代码以做优化或处理平台本身的差异)也能保证Golang程序拥有不弱于C的运行性能。这一点相比较C语言开发而言，实在时友善了太多：

&lt;ul&gt;
&lt;li&gt;C语言为了兼容不通平台，往往会用到条件编译，如果没有实现好好设计跨平台的问题，代码中就会充斥着一大堆#ifdef ，导致可读性极差；但如果每个C语言项目都要去专门为跨平台好好设计一番，却又会导致项目的额外投入以及关注点扩散。总之实际开发中的效率不会高&lt;/li&gt;
&lt;li&gt;C语言标准库功能太薄弱，所以各个平台往往为了相似的基础功能折腾出一堆不通的基础库。尽管后来有了Posix规范，但毕竟这只是个弱约束。比如说巨硬的WinAPI，完全看不到一点Posix的影子，你也不能拿它怎么样。所以还是导致C语言项目会专门为了跨平台投入过多的人力和成本。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Golang提供了一个内存管理机制(含GC)。这相对于原先的C语言开发而言，可算是大大地解放生产力了：

&lt;ul&gt;
&lt;li&gt;C语言开发需要自行管理内存的分配与释放(其实说法不确切，标准库的malloc函数群其实是实现了一个内存池以避免触发过多系统调用)，每一个C语言工程师肯定都与诸如内存泄露，重复释放，野指针误操作等问题搏斗过，费时费力。&lt;/li&gt;
&lt;li&gt;不少C语言开发项目的工作量都耗费在了为本项目进行的内存管理的设计与开发上了。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;得益于Golang自带内存管理功能，因此Golang提供了源生的string类型，而且颇为独特地将内置字符串的文字编码定义为UTF-8(Java，C#，Python3的内置字符串类型的文字编码都是UTF-16)。这样的设计带来了一些显而易见的好处:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;相较于C语言开发，用Golang开发时终于不用自己去处理 &lt;code&gt;char *&lt;/code&gt;指针了。我们学C语言，道行尚浅往往会有个错觉，以为字符串一定会以&amp;rsquo;\0&amp;rsquo;结尾。这个理解得不深刻，往往会给我们带来一些麻烦。之后被坑得多了，才终于反应过来——NM就是一个字节数组。这个积累过程往往需要一些时间，归根结底还是没有一个专门的字符串类型(但事实上，通常情况下，我们要处理的数据有大多数都是字符串)。所以Golang提供了一个string类型也是理所当然。Golang对于String的实现也很符合实际，就是一个形如下方的结构体。这也导致了为什么在Golang中对string进行遍历时是基于字节而非字符来遍历的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct String
{
    byte*   str;
    intgo   len;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;与Java，C#，Python不同的是，Golang的字符串类型的文字编码是UTF8。我个人认为这是考虑到了互联网的需求。毕竟UTF16的每一个字符要占用两个字节。而考虑实际的情况，不管你是传一个html，还是传一个json报文，终究大部分字符还是那些在标准ASCII码范围内的字符。而且，假设数据真的按UTF16来传，还会牵扯到Big-endian和Little-endian的问题。而按UTF8编码传递则没有此问题。可以说，选择UTF-16的话，只对于语言本身的实现时可以减轻不少负担。所幸，Golang的设计者们也认识到了这一点。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Golang中对于函数库的构建，都是统一编译为静态库。当调用者要使用时是要在编译阶段就将函数库静态链接进来的。这个特性有时不被开发者理解，甚至有人认为是一种倒退。但如果我们仔细梳理一下就会发现用静态库时经过深思熟虑的选择：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;部署方便，不会再存在Dependency Hell的问题（代价是程序加载时会多吃点内存）。Linux 系的程序经常陷入Dependency Hell的困扰；而Windows程序虽然稍微好一点，但它是因为在Windows系程序的最佳实践，通常时把所依赖的动态库一并发布。保证程序和程序之间井水不犯河水，以希图消除Dependency Hell的问题，但结果就是，把动态库(又称“共享库”)技术中的“共享”给丢了。&lt;/li&gt;
&lt;li&gt;另一方面，从程序开发技术的历史来看，静态链接技术的诞生是早于动态链接技术的。甚至应该说，动态链接技术更像是静态链接当年面对贫瘠的内存与磁盘资源所做出的一个妥协性质的进化。既然在21世纪的今天，连PC机的内存与磁盘都已经不再是问题的情况下，作为一门新语言，选择在技术上返朴归真也是情有可原。更何况，如果从纯性能角度考量，静态库是要优于动态库的。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Golang还是一门没有实现“类”这个概念但却仍旧可以让你进行面向对象编程的语言。这样一来，概念就非常清晰了，和当年C语言的“简约”的思想一脉相承：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;从80时代开始，“面向对象”思想就开始广为流传。它作为程序设计的一种方法论本身没有错，但问题是如果一个语言非要以支持不支持类这个概念来一刀切地区分自己是不是一个支持面向对象的语言。这就有点走火入魔了。在这方面，Java和C#是这类语言的极端代表，于是写一个入口函数main函数，都得先定义一个类，这实在是让人哭笑不得。更不用说Java和C#在后面的发展中被自己的“必须得有类”的这个概念所坑，先后都引入了一个称之为“静态类”的不伦不类的东西。万幸，Golang吸取了这个教训，没有搞出“类”这个东西。&lt;/li&gt;
&lt;li&gt;面向对象的思想其实是与语言无关，事实上，就算是用C语言也仍然可以在“面向对象”思想的主导下实施开发，从一些优秀开源代码(如PostgreSQL)来看，用C语言也照样可以写出面向对象的风格。与C语言类似，Golang对于“面向对象”思想的三个基本特征也是予以了一定的支持，实现了对“面向对象”技术的“取取其精华去其糟粕”：

&lt;ul&gt;
&lt;li&gt;封装 —— 通过golang的package机制的数据/函数公开规则予以实现&lt;/li&gt;
&lt;li&gt;继承 —— 通过Interface机制在思想上进行了实现（尽管Golang的接口时通过“组合”(Composite)来实现的），但是在语言特性层面却没有专门的“继承”功能&lt;/li&gt;
&lt;li&gt;多态 —— 语言特性上没有专门的“多态”，甚至连函数的参数化多态(Overloading)也不支持&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Golang保留了指针，有助于帮助开发者厘清数据之间关系的真实情况：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在函数参数方面，Java和C#算是捣糨糊的高手。Java为了所谓的“值传递”与“引用传递”，凭空捣鼓出了“原始类型”和“引用类型”这两个概念；C#则更进一步，在彻底地把所有类型都变成“类”了之后，捣鼓出了“值类型”和“引用类型”这两个概念。当然，正式因为这两个高级语言对开发者屏蔽了“地址”(也就是“指针”)这个概念后不得不生造出的概念。其实事情本可以很简单——只要一门语言中的函数调用的参数传递还是基于栈模型(有没有其他模型我不知道&amp;hellip;)，那么参数传递一定是把你希望传递的数据给拷贝走一份后再进行操作。因此，如果你想在一个函数中改变一个已有的数据结构实例中的属性（成员变量），那么你就老老实实地把这个实例的地址(指针)给传过去。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Golang通过&amp;rdquo;接受者&amp;rdquo;(receiver)这个概念，可以把一个函数变成某个数据类型的“方法”，从而相较于C语言的代码更易理解，易维护：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;正如“类”不是必须的，“方法”其实也不是必须的。receiver这个特性更像是一个语法糖。只是，有了方法之后从代码层面就可以更明显地看出一个操作和一个数据结构之间时强联系还是弱联系。也正因为有了这个特性，所以Golang的“面向对象”的特征就“更加明显”了。&lt;/li&gt;
&lt;li&gt;写C语言代码时，通常为了在代码中体现一个函数与一个数据结构是强联系，函数是数据结构的“方法”，所以通常会选择把这个数据结构的参数放在函数参数列表的第一个。也许Golang设计团队对于这个最佳实践也是深有感触之后才下决心做了“receiver”这个特性。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Golang中的&lt;code&gt;defer&lt;/code&gt;机制可以有效增强代码的健壮性。用其他语言写代码，一旦涉及到数据库连接，文件句柄等资源操作时要格外小心，生怕有什么分支忘记关闭这些资源。有了defer机制，打可以在打开资源语句的下一条语句就用defer把关闭资源的操作塞入栈中，确保关闭操作一定被执行。并且有效地减少了函数中各种退出分支中冗长的关闭资源代码。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;至于Golang语言中以go关键字和chan关键字体现出的 “协程”和 “信道”这两个并发程序开发中的利器，已经有太多人盛赞过了，这里就不在赘述。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;从以上可以看出，其实Golang语言的一些特性是源于C语言，但又更好地解决了C语言开发中的一些通点，使得在不太牺牲性能的前提下提升开发效率。Golang团队不愧是有C语言的发明者之一的Ken Tompson参与，所以能够有的放矢地去改善C语言在新时代形势下的一些课题。&lt;/p&gt;

&lt;p&gt;然而，Golang中终究还是有一些我个人觉得比较遗憾的地方，也记录在此吧:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;以 &lt;code&gt;${变量名} 类型&lt;/code&gt; 这样类型在后的声明方式终究还是太小众了，特别是有时候定义函数时，写着写着就把参数列表写成了 类型 ${参数名} 这样的传统方式了。然后非要等编译出错才能反应过来(有时候还未必能反应过来)。 类型在后的声明方式，想了半天似乎也就只有&lt;strong&gt;SQL&lt;/strong&gt;是这样的。&lt;/li&gt;
&lt;li&gt;与C语言一样，Golang中无法定义参数类型不同，函数名与返回值类型相同的 所谓&lt;a href=&#34;https://en.wikipedia.org/wiki/Function_overloading&#34;&gt;Function Overloading&lt;/a&gt;。因此一个功能相同仅仅是为了处理不同参数类型的一组函数，非得费破脑细胞取给各个函数想名字，这也是很无奈的。&lt;/li&gt;
&lt;li&gt;Golang因为是 强类型 &amp;amp; 静态类型 的关系(C语言是 弱类型 &amp;amp; 静态类型)，很多在C语言，Java, C#中都可以隐式类型转换的写法在C语言中必须得做显式类型转换，代码就难免会多起来。感觉语言设计者想通过这种方式来甩锅啊&amp;hellip;&amp;hellip;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;不过，瑕不掩瑜。Golang还是一门非常值得学习的语言。2015年末我自学了Python，本来想好好研究一下Python的。结果一接触Golang之后，就立刻爱不释手，我想大概还是因为我是从C语言这一路学习过来的吧。所以我建议所有有C语言开发经验的人都取接触一下Golang，也许就会和我一样有“相见恨晚”的感觉。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>