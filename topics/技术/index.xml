<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>小wing的驿站</title>
    <link>https://xiaowing.github.io/topics/%E6%8A%80%E6%9C%AF/index.xml</link>
    <description>Recent content on 小wing的驿站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>&amp;copy; Licensed under CC BY-NC-SA.</copyright>
    <atom:link href="https://xiaowing.github.io/topics/%E6%8A%80%E6%9C%AF/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>[译文]Python为何会成为机器学习领域的主流语言</title>
      <link>https://xiaowing.github.io/post/20170913_python_and_machine_learning_cn/</link>
      <pubDate>Wed, 13 Sep 2017 21:37:02 +0800</pubDate>
      
      <guid>https://xiaowing.github.io/post/20170913_python_and_machine_learning_cn/</guid>
      <description>&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;pure-u-1-1&#34;&gt;
    &lt;div style=&#34;padding: 0 .2em&#34;&gt;
      &lt;img
        class=&#34;pure-img-responsive&#34;
        src=&#34;https://xiaowing.github.io/img/post/python-logo.png&#34;
        alt=&#34;Python Logo&#34;&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;


&lt;p&gt;最近因为在改PostgreSQL的相关的一些代码，因此在自学Perl语言。虽然和Python一样，它也是门解释型语言，然而这门语言真的是比较奇葩，因此无比地怀念Python.&lt;/p&gt;

&lt;p&gt;Python是我2015年自学的，虽然没用它做过什么正经的项目，但是小东西还是写了不少。只可惜自己终究还是修行不够，否则在目前这个被&amp;rdquo;人工智能&amp;rdquo;，“机器学习”等概念刷屏的年代，借助Python这门深受机器学习领域欢迎的语言，我说不定也能包装成一个年薪百万的大咖~&lt;/p&gt;

&lt;p&gt;不过，为什么机器学习领域会如此欢迎Python？之前在一个日文网站上看到一篇文章说这个事情，我觉得写得有点意思，所以就把它翻译了一下&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;python为何会成为机器学习领域的主流语言&#34;&gt;Python为何会成为机器学习领域的主流语言&lt;/h2&gt;

&lt;p&gt;原题: 機械学習でPythonが主流になっている必然的な理由とは&lt;/p&gt;

&lt;p&gt;作者: 株式会社キャパ&lt;/p&gt;

&lt;p&gt;链接: &lt;a href=&#34;http://www.capa.co.jp/archives/13875&#34;&gt;http://www.capa.co.jp/archives/13875&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0&#34;&gt;机器学习&lt;/a&gt;,或者说&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0&#34;&gt;深度学习&lt;/a&gt;的领域, Python正成为主流的编程语言。&lt;/p&gt;

&lt;p&gt;在海外，Python是作为一个用于编程教育的语言而慢慢普及开来的;但是在日本国内，Python则几乎没怎么受到过关注(&lt;em&gt;译注: 相对于Python，日本业界对于Ruby的关注度更高，大概因为Ruby是日本人发明的吧&lt;/em&gt;).那么，为什么在机器学习领域Python会成为主流呢？这其中有以下几个缘由:&lt;/p&gt;

&lt;h3 id=&#34;为什么选择了python-而不是c&#34;&gt;为什么选择了Python，而不是C++?&lt;/h3&gt;

&lt;p&gt;你知道解释型语言(通称:脚本语言)与编译型语言的差异吗？&lt;/p&gt;

&lt;p&gt;前者以Python以及Ruby为代表的语言，后者则因C语言或C++而广为人知。解释型语言是不管你将代码写到什么程度，随时都可以把写好的代码立刻运行起来;但是后者的编译型语言则必须遵循一定的编译手顺生成可执行文件之后，然后才能把它执行起来。编译型语言需要开发者在编译上花费一定的时间以及精力，但相对的，它的执行起来的性能是非常高速的。&lt;/p&gt;

&lt;p&gt;在机器学习领域，往往会涉及到大量的计算。理论上处理速度应该是越快越好，但为什么它选择了不是编译型语言的Python？其中有这么几点原因:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;“编码-运行”的周期可以变得更短&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在机器学习，或者深度学习领域，往往需要开发者写了代码以后立刻运行一下，根据运行结果进而修正相应的代码，之后再执行——这样的循环过程在实际开发中会再三反复。如果在这样的开发中选用了编译型语言，也就意味着在开发过程中实际上又要加入一个编译的过程，因此可以预见开发的生产性会下降。&lt;/p&gt;

&lt;p&gt;而且在编译型语言中，数据的&amp;rdquo;类型&amp;rdquo;是很受重视的，但是Python却是一个动态类型的语言，因此编码中根本无需声明数据的类型。对于同时有可能处理各种数据的机器学习而言，如果是用重视类型的编译型语言去一个个事先定义好数据的类型，写代码的时间应该会被拉长不少吧。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;拥有各种各样的涉及高速运算的程序库&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在Python中，拥有以&lt;code&gt;Numpy&lt;/code&gt;和&lt;code&gt;Scipy&lt;/code&gt;为代表的高速处理数值计算的程序库。因为有了这些库，尽管Python是解释型语言，但是可以借助它们的高速化而使人们不再对Python性能而感到担心。除此之外，还有&lt;code&gt;Matplotlib&lt;/code&gt;之类的绘图库，因此可以很简单地将机器学习的结果以图或表的形式展现出来。再借助&lt;code&gt;Django&lt;/code&gt;这个Web框架，就可以将机器学习的结果很方便地公开为一个Web服务，&lt;/p&gt;

&lt;p&gt;当然，Python中用于机器学习以及深度学习的各种程序库还在不断充实中。比如享誉业界的Google出品的&lt;code&gt;TensorFlow&lt;/code&gt;框架,以及&lt;code&gt;Caffe&lt;/code&gt;, &lt;code&gt;Scikit-learn&lt;/code&gt;, &lt;code&gt;Theano&lt;/code&gt;等等。Python中这些程序库/框架的充实度以及Python在机器学习中的流行度这两者之间，现在已经说不清到底是先有的鸡还是先有的蛋。总之，随着用户的增多，Python在机器学习方面的生态也的确会越变越好吧。&lt;/p&gt;

&lt;h3 id=&#34;r语言-与-python&#34;&gt;R语言 与 Python&lt;/h3&gt;

&lt;p&gt;R语言是数据科学家们用于进行数据统计的一门语言。而机器学习以及深度学习的知识领域其实与数据科学在很多方面是重合的。此外，在最初的阶段，R语言的程序库的性能普遍要更好。因此，一开始的时候普遍认为R语言会成为该领域的主流。&lt;/p&gt;

&lt;p&gt;但是，机器学习毕竟是需要通过软件开发人员来落地并实现的，比起只在数据科学家圈子中运用的R语言，对于软件开发人员而言，如果能用相对熟悉的Python语言来做，那当然会倾向于选择用Python来实现。因此，最终反而是Python中这方面的程序库变得更加充实起来。&lt;/p&gt;

&lt;h3 id=&#34;时势造就的python英雄&#34;&gt;时势造就的Python英雄&lt;/h3&gt;

&lt;p&gt;就结果而言，Python现今成了机器学习领域的主流语言。不过，这其实也谈不上是“必然”，只是经由时代选择而得到的一个结果而已。今后也许会发明一种专门面向机器学习领域的语言也说不定。只是目前还是暂时让Python的时代继续一段时间吧。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>如何为PostgreSQL创建一个内置函数？</title>
      <link>https://xiaowing.github.io/post/20170903_howto_create_a_postgres_builtin_function/</link>
      <pubDate>Sun, 03 Sep 2017 22:59:31 +0800</pubDate>
      
      <guid>https://xiaowing.github.io/post/20170903_howto_create_a_postgres_builtin_function/</guid>
      <description>&lt;p&gt;这篇文章我已经酝酿颇久了，诱因是因为&lt;a href=&#34;https://www.pingcap.com/index-zh&#34;&gt;PingCAP&lt;/a&gt;团队为了推广他们的&lt;strong&gt;TiDB&lt;/strong&gt;而在知乎专栏发了一篇文章《&lt;a href=&#34;https://zhuanlan.zhihu.com/p/24870620&#34;&gt;TiDB 增加 MySQL 内建函数&lt;/a&gt;》。受此文启发，我在网上搜索了一下&lt;strong&gt;PostgreSQL&lt;/strong&gt;(&lt;em&gt;以下略称&amp;rdquo;PG&amp;rdquo;&lt;/em&gt;)中定制内置函数(&lt;em&gt;Built-in Function&lt;/em&gt;)相关的文章，果然没有搜到什么像样的中文文章。其实为PG添加内置函数并不难，可能是相对于hacking它的SQL引擎或者存储引擎等等话题而言，加一个内置函数的逼格实在是太Low吧。不过TiDB这个诞生还没多久的数据库产品都知道通过先利用内置函数这个话题来由简入深地吸引广大开发者为它贡献代码，PG作为一个诞生了已有20年的开源数据库老大哥却没有一篇像样文章，也难怪PG的普及率不高了。&lt;/p&gt;

&lt;p&gt;以上就作为这篇分享的「意味づけ」吧&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;什么时候需要去增加一个内置函数&#34;&gt;什么时候需要去增加一个内置函数&lt;/h2&gt;

&lt;p&gt;其实在大多数情况下，鉴于PG提供了强大的SQL扩展能力，我们通常只需要掌握PG中&lt;a href=&#34;https://www.postgresql.org/docs/9.6/static/xfunc.html&#34;&gt;User Define Function(略称:UDF)&lt;/a&gt;就够了。不过内置函数的特性与UDF还是有些不同的，因此在一些特定场景下，我们可能会不得不采用内置函数的方式去定制一些函数接口。&lt;/p&gt;

&lt;p&gt;以下，我对比了一下内置函数和UDF的特性&amp;hellip;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;扩展灵活性&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;内置函数&lt;/em&gt;&lt;br/&gt;
不灵活。&lt;br/&gt;对内置函数的增/删/改都必须通过修改并重编PostgreSQL源码实现。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;User Defined Function&lt;/em&gt;&lt;br/&gt;
很灵活。&lt;br/&gt;通过&lt;code&gt;CREATE FUNCTION&lt;/code&gt;以及&lt;code&gt;DROP FUNCTION&lt;/code&gt;就可以实现UDF的增加与删除.且函数的具体实现可以通过多种语言(PL/pgsql,PL/python,PL/Perl等等)实现。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可见性&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;内置函数&lt;/em&gt;&lt;br/&gt;
内置函数默认在所有实例的所有Database中都可见&lt;/li&gt;
&lt;li&gt;&lt;em&gt;User Defined Function&lt;/em&gt;&lt;br/&gt;
由于UDF只是一个数据库对象。因此对于一个特定的UDF而言，一次CREATE FUNCTION只能使得它在该特定的Database中可见。若要在别的Database中也可见，需要在目标Database中也执行&lt;code&gt;CREATE FUNCTION&lt;/code&gt;语句&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;执行权限&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;内置函数&lt;/em&gt;&lt;br/&gt;
除非在内置函数的实现中做特定限制逻辑，否则内置函数默认对所有的数据库用户可执行&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;User Defined Function&lt;/em&gt;&lt;br/&gt;
默认只有创建了的该UDF数据库用户拥有执行权限，对于其他用户，需要通过&lt;code&gt;GRANT&lt;/code&gt;语句赋权&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于大部分PG用户而言，他们对SQL级别的函数的期待通常都是与具体业务数据紧密相关的(其中的大部分都是希望去实现一些存储过程),因此对于这部分用户而言，UDF已经足够(PG中“存储过程”这个概念已被融入UDF)。通常，只有在以下这几种场景下，我们才需要去实现一个内置函数:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;希望在SQL层面查询PG运行中的一些临时的内部状态(常见于做PG的商业发行版时为了为了满足一些特定需求)&lt;/li&gt;
&lt;li&gt;希望在SQL层面可以对PG的内部执行加以一些控制(常见于做PG的商业发行版时为了满足一些特定需求)&lt;/li&gt;
&lt;li&gt;纯粹只是想Hacking一下PG&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;增加内置函数的-三板斧&#34;&gt;增加内置函数的&amp;rdquo;三板斧&amp;rdquo;&lt;/h2&gt;

&lt;p&gt;其实为PG增添一个内置函数本身并不复杂，我总结下来也就三个步骤: &lt;strong&gt;实现函数&lt;/strong&gt;，&lt;strong&gt;声明函数&lt;/strong&gt; &amp;amp; &lt;strong&gt;注册函数&lt;/strong&gt;。下面我就用一个简单的例子来说明如何给PG增加一个内置函数。&lt;/p&gt;

&lt;h3 id=&#34;1-实现&#34;&gt;1. 实现&lt;/h3&gt;

&lt;p&gt;仿照《&lt;a href=&#34;https://book.douban.com/subject/26220250/&#34;&gt;PostgreSQL服务器编程&lt;/a&gt;》一书中的第8章实现一个最简单的函数:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;输入两个INTEGER的参数，返回一个表示两数相加及其结果的等式(TEXT)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;实现的代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;Datum
add_str(PG_FUNCTION_ARGS) {
    int arg_1, arg_2;
    char buf[128] = {0x00};
    char *result = NULL;

    if (PG_ARGISNULL(0) || PG_ARGISNULL(1)) {
        ereport(ERROR, 
            (errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED), 
             errmsg(&amp;quot;cannot specify NULL as the arguement.&amp;quot;)));
    }

    arg_1 = PG_GETARG_INT32(0);
    arg_2 = PG_GETARG_INT32(1);

    snprintf(buf, 128, &amp;quot;%d + %d = %d&amp;quot;, arg_1, arg_2, (arg_1 + arg_2));
    result = pstrdup(buf);

    PG_RETURN_TEXT_P(cstring_to_text(result));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里需要注意的是，与用C语言编写UDF一样，编写的函数必须是一个&lt;strong&gt;fmgr-compatible&lt;/strong&gt;的函数。即参数必须是&lt;code&gt;PG_FUNCTION_ARGS&lt;/code&gt;, 返回值必须是&lt;code&gt;Datum&lt;/code&gt;。这是由于PG中所有的SQL函数(含内置函数以及UDF)都被一个通用模块模块管理，该模块通过自己的一套机制去定位并执行SQL文中指定的SQL函数(SQL文中的函数调用机制，后面会另写博客分享)。&lt;/p&gt;

&lt;p&gt;上述函数可以实现在PG中的任何一个代码文件中(当然也可以新建一个源文件定于)。不过需要注意的是，必须确保这个源文件包含了&lt;code&gt;&amp;quot;funcapi.h&amp;quot;&lt;/code&gt;这个头文件。&lt;/p&gt;

&lt;p&gt;此外，这个例子只是为了示意，所以做了一个最简单的逻辑。在实际开发中，对于SQL函数，通常有一类需求是希望函数返回一个结果集。对于返回结果集的SQL函数，PG中称之为&lt;code&gt;SRF&lt;/code&gt;(Set Returning Functions). SRF的实现有一个固定范式，详细可以参见PG代码中的&lt;code&gt;src/include/funcapi.h&lt;/code&gt;的注释，内有关于这个范式的详细说明。&lt;/p&gt;

&lt;h3 id=&#34;2-声明&#34;&gt;2. 声明&lt;/h3&gt;

&lt;p&gt;PG中对于内置函数的声明有一个约定俗成的共通位置，即PG源码中的&lt;code&gt;src/include/utils/builtin.h&lt;/code&gt;。通常都是在该头文件中将实现的内置函数声明为一个extern函数以确保其对其他源码文件可见。&lt;/p&gt;

&lt;p&gt;不过，这也只是一个惯例而已，事实上，内置函数的声明位置并不一定限定与此。说白了，只要保证这个声明能让整个fmgr机制看到即可。&lt;/p&gt;

&lt;p&gt;函数声明本身全无特别，在本例中，声明就只是下面简单的一句话：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;extern Datum add_str(PG_FUNCTION_ARGS);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-注册&#34;&gt;3. 注册&lt;/h3&gt;

&lt;p&gt;Last but not least. 对于内置函数而言，光有实现和声明是不够的。与其他的数据库对象相仿，内置函数的元信息必须写入PG的数据字典中。而且由于系统表是数据库实例生来就有的对象，并没有一个CREATE文能帮它把元信息写入数据字典，因此这个步骤必须在源码中事先完成。这就是所谓的&lt;strong&gt;注册&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;与UDF一样，内置函数的元数据也是保存在系统表&lt;code&gt;pg_proc&lt;/code&gt;中的。而&lt;code&gt;pg_proc&lt;/code&gt;系统表在PG的数据库模板中初始状态下所具有的元数据元组是在&lt;code&gt;src/include/catalog/pg_proc.h&lt;/code&gt;中注册的。每个元组的注册格式如下:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;DATA(insert OID = 元组的唯一OID (  内置函数名 属性1 属性2&amp;hellip;&amp;hellip; ));&lt;br/&gt;
DESCR(内置函数的描述信息(使用半角双引号引起来));&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;为&lt;code&gt;pg_proc.h&lt;/code&gt;增加一个形如上文的元组时，有两个地方需要注意:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;OID必须保证全局唯一&lt;/p&gt;

&lt;p&gt;为&lt;code&gt;pg_proc.h&lt;/code&gt;增加元组时，必须分配一个&lt;strong&gt;9999&lt;/strong&gt;以内的唯一OID(在写下一个OID之前，可以先全文搜索一下PG源码确保其唯一性)&lt;/p&gt;

&lt;p&gt;至于为什么一定要将这个OID选在&lt;strong&gt;9999&lt;/strong&gt;以内，是因为PG源码的&lt;code&gt;src/include/access/transam.h&lt;/code&gt;对于Oid使用范围存在下述描述，且通过两个宏定义来限定:&lt;/p&gt;



&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;pure-u-1-1&#34;&gt;
    &lt;div style=&#34;padding: 0 .2em&#34;&gt;
      &lt;img
        class=&#34;pure-img-responsive&#34;
        src=&#34;https://xiaowing.github.io/img/post/about_oid.jpg&#34;
        alt=&#34;Object ID&#34;&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;


&lt;p&gt;在本例中，通过甄选，将&lt;code&gt;add_str&lt;/code&gt;内置函数在&lt;code&gt;pg_proc&lt;/code&gt;中元祖的OID选为&lt;strong&gt;5946&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;元组各个字段属性的写法&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pg_proc.h&lt;/code&gt;中内置函数的元数据的元组格式咋一看估计会让人懵掉。但实际上，这里的元组的各个属性(函数名已降的各字段)实际上对应的就是PostgreSQL手册中&lt;a href=&#34;https://www.postgresql.org/docs/9.6/static/catalog-pg-proc.html&#34;&gt;pg_proc系统表的各个字段&lt;/a&gt;。对照着这一章节的介绍以及参考&lt;code&gt;pg_proc.h&lt;/code&gt;中已有的内置函数的元组，就可知道该如何为新的内置函数增添元组。&lt;/p&gt;

&lt;p&gt;以下是在手册基础上，对pg_proc的元组各字段数据的写法做的一些补充说明:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;proisstrict&lt;/br&gt;
如果将此字段设置为&lt;code&gt;t&lt;/code&gt;, 只要通过SQL调用该函数时参数中有一个NULL，那么这个函数实际上不会被调用(即便函数实现中预备了对于NULL的处理)而是直接返回一个NULL。因此如果希望自己处理NULL参数，该字段不应为&lt;code&gt;t&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;proparallel&lt;/br&gt;
这个字段是 9.6 开始新加的字段。表示的是这个函数是否支持在并行查询的模式下并行执行。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;prorettype&lt;/br&gt;
返回值类型。这里需要填入的是返回值类型所对应的OID。这些OID可以在&lt;code&gt;src/include/catalog/pg_type.h&lt;/code&gt;中寻找。但需要注意的是，这里填的OID不要使用宏定义，直接填OID的数字。另外，结果集对应的OID是&lt;code&gt;2249&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;proargtypes和proallargtypes&lt;/br&gt;
这两个字段都需要以集合的形式写出参数类型OID集合。但写法上略有差别:&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;proargtypes的写法是&lt;code&gt;&amp;quot;OID1 OID2 ...&amp;quot;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;proallargtypes的写法是&lt;code&gt;{OID1 OID2 ...}&lt;/code&gt;。此外，如果返回值是一个结果集的话，填写此字段时，结果集中各个字段的类型也需要在&lt;code&gt;proallargtypes&lt;/code&gt;中严格按照结果集字段的顺序一一声明。在这里，结果集字段与输出参数可以视作等同效果.如果函数不包括任何输出参数且返回值不是结果集的话，这个字段可以直接声明为&lt;code&gt;_null_&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外，对于返回值是结果集的内置函数而言，也许要把结果集的每一个字段的信息反映在&lt;code&gt;proargmodes&lt;/code&gt;和&lt;code&gt;proargnames&lt;/code&gt;这两个属性中。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于本例的&lt;code&gt;add_str()&lt;/code&gt;函数比较简单，因此它在&lt;code&gt;pg_proc.h&lt;/code&gt;中对应的元组可写为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;DATA(insert OID = 5946 (  add_str PGNSP PGUID 12 1 0 0 0 f f f f f f s s 2 0 25 &amp;quot;23 23&amp;quot; _null_ _null_ _null_ _null_ _null_ add_str _null_ _null_ _null_ ));
DESCR(&amp;quot;add_str just for test&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到这里为止，向PG源码中增添新的内置函数的方法就已经介绍完毕了。但是在实践中，除了上述&amp;rdquo;三板斧&amp;rdquo;，还有一些坑最好也事先知道，以免在增添内置函数时走弯路.&lt;/p&gt;

&lt;h2 id=&#34;踩过的那些坑&#34;&gt;踩过的那些坑&lt;/h2&gt;

&lt;h3 id=&#34;坑1-内置函数的参数默认值&#34;&gt;坑1. 内置函数的参数默认值&lt;/h3&gt;

&lt;p&gt;PG中的SQL函数的参数是可以定义默认值的，然而C语言编写的函数是没有办法为其参数指定默认值的。这个Gap还是必须得从PG自己的机制着手。好消息是&lt;code&gt;pg_proc&lt;/code&gt;系统表中有一个字段叫做&lt;code&gt;proargdefaults&lt;/code&gt;,它看上去似乎可以用于解决参数默认值的问题; 但坏消息是，这个字段接受的是一个以字符串形式表示的&lt;code&gt;Express Tree&lt;/code&gt;，这几乎不是常人能通过人手能够写出来的。&lt;/p&gt;

&lt;p&gt;幸运的是，PG社区的大牛&lt;strong&gt;Tome Lane&lt;/strong&gt;在&lt;a href=&#34;https://www.postgresql.org/message-id/24148.1239060256@sss.pgh.pa.us&#34;&gt;2009年的一封邮件&lt;/a&gt;中指出了为内置函数设置默认值的正确姿势: 不要尝试在&lt;code&gt;pg_proc.h&lt;/code&gt;中通过元组的方式指定参数默认值——因为这种方式很&amp;rdquo;Ugly&amp;rdquo;——而是应该通过在&lt;code&gt;src/backend/catalog/system_views.sql&lt;/code&gt;中通过SQL文定义一个带默认值参数的函数去覆盖用C语言编写的SQL函数。比如，他在邮件中提到的内置函数&lt;code&gt;pg_start_backup()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE OR REPLACE FUNCTION
  pg_start_backup(label text, fast boolean DEFAULT false)
  RETURNS text LANGUAGE internal STRICT AS &#39;start_backup&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;换言之，可以先用C语言实现希望增加的内置函数的逻辑，再通过在&lt;code&gt;system_views.sql&lt;/code&gt;中创建SQL函数接口。当然，这个C语言函数仍然得遵循上文所说&lt;code&gt;fmgr-compatible&lt;/code&gt;范式.另外，由于&lt;code&gt;system_views.sql&lt;/code&gt;中定义的函数不是预先写入数据库模板中的，而是在&lt;code&gt;initdb&lt;/code&gt;创建实例的bootstrap过程中执行的，因此这样的函数的OID必然是在10000之后。&lt;/p&gt;

&lt;h3 id=&#34;坑2-pg-proc-h中新元组的生效时机&#34;&gt;坑2. pg_proc.h中新元组的生效时机&lt;/h3&gt;

&lt;p&gt;按照前文所述的&amp;rdquo;三板斧&amp;rdquo;来编写一个内置函数时，如果所用的PG源码所展开的路径是第一次执行编译还好，如果在所展开的路径下先前已经编译过至少一次的情况下，这时就会出现一个神奇的现象：重编后的二进制中可以看到新加的内置函数但无论如何就是没法走到。&lt;/p&gt;

&lt;p&gt;这是因为当我们给&lt;code&gt;pg_proc.h&lt;/code&gt;中增加新的内置函数对应的元组时，以下三个文件会在源码编译过程中基于&lt;code&gt;pg_proc.h&lt;/code&gt;的内容自动生成。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;src/backend/catalog/postgres.bki&lt;/br&gt;
src/backend/utils/fmgroids.h&lt;/br&gt;
src/backend/utils/fmgrtab.c&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这三个文件中生成的内容对于&lt;code&gt;pg_proc&lt;/code&gt;系统表中的初始化元组起重要作用。但是这三个文件只会在第一次编译时生成且并不会在&lt;code&gt;make clean&lt;/code&gt;时被清理掉。因此，如果是在一个已经执行过至少一次编译的源码环境中增加新的内置函数时，若要&amp;rdquo;三板斧&amp;rdquo;的最后一斧生效，必须在编译前执行下述命令:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$make maintainer-clean
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，这样一来原本生成的所有Makefile也将被清理掉，之后要编译这份代码的话，必须从&lt;code&gt;./configure&lt;/code&gt;重新开始。&lt;/p&gt;

&lt;h2 id=&#34;创建内置函数时最好知道的pg内部api&#34;&gt;创建内置函数时最好知道的PG内部API&lt;/h2&gt;

&lt;p&gt;用C语言为PG做扩展有一些通用的内部接口可供使用，这些接口也不限于内置函数。所以在我所知道的范围内列出一些内部接口，以作备忘:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.postgresql.org/docs/9.6/static/spi.html&#34;&gt;SPI系列函数&lt;/a&gt;&lt;/br&gt;
可以用于在内部执行SQL等等&lt;/li&gt;
&lt;li&gt;直接操作元组(Tuple)相关API

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CreateTemplateTupleDesc()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TupleDescInitEntry()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BlessTupleDesc()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;heap_from_tuple()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;用于查询执行时当前会话状态判断的实用函数

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;superuser()&lt;/code&gt;&lt;/br&gt;
判断当前用户是否是DB的超级用户&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IsTransaction()&lt;/code&gt;&lt;/br&gt;
判断当前语句是否在一个显式事务块中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IsInParallelMode()&lt;/code&gt;&lt;/br&gt;
判断当前是否在并行执行模式中&lt;/li&gt;
&lt;li&gt;全局变量 &lt;code&gt;XactReadOnly&lt;/code&gt;&lt;/br&gt;
判断当前会话是否是只读模式&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;

&lt;p&gt;以上就是给PG添加内置函数的方法的一个小结，也是我最近一段时间一直在折腾PG的SQL函数所做的一点积累, 希望能够为有类似需求的人提供一些帮助。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[译文]GO语言是面向对象的吗？</title>
      <link>https://xiaowing.github.io/post/20170816_is_go_object_oriented_cn/</link>
      <pubDate>Wed, 16 Aug 2017 21:48:52 +0800</pubDate>
      
      <guid>https://xiaowing.github.io/post/20170816_is_go_object_oriented_cn/</guid>
      <description>&lt;p&gt;周一在微信上收到了&lt;a href=&#34;http://www.weixinyidu.com/a_277786&#34;&gt;Go中国&lt;/a&gt;公众号推送的一篇文章 &lt;a href=&#34;https://flaviocopes.com/golang-is-go-object-oriented/&#34;&gt;Is GO object oriented&lt;/a&gt; ,读完以后感觉观点还是很有意思的，与我的所见有很多相似之处，所以就饶有兴趣地把它翻译成中文，也算是作为&amp;rdquo;友军&amp;rdquo;的一点贡献吧&amp;hellip;&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;go语言是面向对象的吗&#34;&gt;GO语言是面向对象的吗？&lt;/h2&gt;

&lt;p&gt;原题: IS GO OBJECT ORIENTED?&lt;/p&gt;

&lt;p&gt;作者: Flavio Copes&lt;/p&gt;

&lt;p&gt;链接: &lt;a href=&#34;https://flaviocopes.com/golang-is-go-object-oriented/&#34;&gt;https://flaviocopes.com/golang-is-go-object-oriented/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;有时候我会读到文章宣称&amp;rdquo;GO语言是面向对象的语言&amp;rdquo;，有时候我又会读到一篇持相反观点的文章宣称&amp;rdquo;GO语言无法做到面向对象编程因为它根本没有&amp;rsquo;类&amp;rsquo;&amp;ldquo;.&lt;/p&gt;

&lt;p&gt;有鉴于此，我写了这篇文章来阐述这个话题: &lt;strong&gt;GO语言到底是不是面向对象的语言&lt;/strong&gt;？&lt;/p&gt;

&lt;p&gt;如果你习惯了从某种特定编程语言的视角来思考问题，那么在这个话题上，你可能会由于自己所惯于使用的语言不同而得出截然相反的答案。比如说，如果你之前习惯了使用C语言，那么很显然GO语言拥有太多面向对象的特性；但是如果你之前习惯了使用Java，那么GO语言看起来就不那么&amp;rdquo;面向对象&amp;rdquo;了。&lt;/p&gt;

&lt;p&gt;因此关于这个话题，你首先要做的是摒弃其他语言带给你的先入为主的观念并学会用GO语言的思维模式来思考。&lt;/p&gt;

&lt;p&gt;然后我就可以给出我的答案了: YES. GO语言是一门面向对象的语言, 而且是以一种很清爽的方式实现了面向对象.&lt;/p&gt;

&lt;p&gt;在&lt;a href=&#34;https://golang.org/doc/faq#Is_Go_an_object-oriented_language&#34;&gt;GO语言官方文档的FAQ&lt;/a&gt;中也表述过下述内容&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Is Go an object-oriented language?&lt;/p&gt;

&lt;p&gt;Yes and no. Although Go has types and methods and
allows an object-oriented style of programming, there
is no type hierarchy. The concept of “interface” in Go
provides a different approach that we believe is easy
to use and in some ways more general. There are also
ways to embed types in other types to provide something
analogous—but not identical—to subclassing. Moreover,
methods in Go are more general than in C++ or Java:
they can be defined for any sort of data, even built-in
types such as plain, “unboxed” integers. They are not
restricted to structs (classes).
Also, the lack of a type hierarchy makes “objects” in
Go feel much more lightweight than in languages such as
C++ or Java.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;集众家所长&#34;&gt;集众家所长&lt;/h3&gt;

&lt;p&gt;GO语言从&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E8%BF%87%E7%A8%8B%E5%BC%8F%E7%BC%96%E7%A8%8B&#34;&gt;过程式编程语言&lt;/a&gt;, &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B8%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80&#34;&gt;函数式编程语言&lt;/a&gt;以及&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1&#34;&gt;面向对象编程语言&lt;/a&gt;中都汲取了一些概念并将它们组装在一起后，将那些剩余的概念舍弃从而创造了一门极具特性但又十分地道的编程语言。&lt;/p&gt;

&lt;h3 id=&#34;要结构体-不要类&#34;&gt;要结构体,不要类&lt;/h3&gt;

&lt;p&gt;GO语言中并没有传统面向对象编程语言中的&amp;rdquo;类&amp;rdquo;(&lt;code&gt;class&lt;/code&gt;)的概念，取而代之的是使用了&amp;rdquo;结构体&amp;rdquo;(&lt;code&gt;struct&lt;/code&gt;)。但是GO语言的结构体可比C语言中的同名前辈要强大得多。在GO语言中,结构体以及结构体的方法(&lt;code&gt;method&lt;/code&gt;)发挥了与传统意义上的&amp;rdquo;类&amp;rdquo;相同的作用，同时在概念上又清晰分明——结构体只负责管理状态，不管理行为;而结构体的方法则负责定义结构体的行为，比如说允许他们更改状态.&lt;/p&gt;

&lt;h3 id=&#34;封装的奥义&#34;&gt;封装的奥义&lt;/h3&gt;

&lt;p&gt;我认为GO语言中最好的一个特性就是，直接明了地通过字段名, 方法名以及函数名的首字母大写来保证它们的访问可见性为&lt;strong&gt;public&lt;/strong&gt;。其他的那些以小写字母开头的字段等则默认为包(&lt;code&gt;package&lt;/code&gt;)内私有(private)并且无法被导出至包外。这个特性使得开发者们一眼就可以看出来哪些字段/方法/属性是public的，哪些是private的。另外，由于GO语言中没有&lt;strong&gt;继承&lt;/strong&gt;这一概念，所以GO语言中的访问修饰也就根本没有&lt;code&gt;protected&lt;/code&gt;的概念.&lt;/p&gt;

&lt;h3 id=&#34;无继承&#34;&gt;无继承&lt;/h3&gt;

&lt;p&gt;GO语言中没有&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%BB%A7%E6%89%BF_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)&#34;&gt;继承&lt;/a&gt;,这一点在&lt;a href=&#34;https://golang.org/doc/faq#Why_is_there_no_type_inheritance&#34;&gt;GO语言官方文档的FAQ&lt;/a&gt;也有明确说明:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Object-oriented programming, at least in the best-known
languages, involves too much discussion of the
relationships between types, relationships that often
could be derived automatically. Go takes a different
approach.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;用组合代替继承&#34;&gt;用组合代替继承&lt;/h3&gt;

&lt;p&gt;程序设计理念中最广为认知的准则之一即是 &lt;a href=&#34;https://en.wikipedia.org/wiki/Composition_over_inheritance&#34;&gt;用组合代替继承&lt;/a&gt;。这一准则在&lt;a href=&#34;https://en.wikipedia.org/wiki/Design_Patterns&#34;&gt;四人帮&lt;/a&gt;的那本极富盛名的《设计模式》也屡有提及。而在GO语言中，这一准则被发挥得淋漓尽致。&lt;/p&gt;

&lt;p&gt;当我们在定义一个结构体时，我们可以追加类型为另一个结构体的匿名字段。这样一来，我们定义的这个结构体也就同时拥有了另一个结构体的所有字段以及方法。这种技法被称之为&lt;strong&gt;Struct Embedding&lt;/strong&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

type Dog struct {
	Animal
}
type Animal struct {
	Age int
}

func (a *Animal) Move() {
	fmt.Println(&amp;quot;Animal moved&amp;quot;)
}
func (a *Animal) SayAge() {
	fmt.Printf(&amp;quot;Animal age: %d\n&amp;quot;, a.Age)
}
func main() {
	d := Dog{}
	d.Age = 3
	d.Move()
	d.SayAge()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://play.golang.org/p/IxMoeByWp5&#34;&gt;执行结果&lt;/a&gt; (需要科学上网)&lt;/p&gt;

&lt;h3 id=&#34;接口&#34;&gt;接口&lt;/h3&gt;

&lt;p&gt;忘记Java或PHP风格的接口概念吧！GO语言中的接口是截然不同的，而其中最关键的一个特性即是: &lt;strong&gt;接口是隐式实现的&lt;/strong&gt;——不需要在定义类型时去显式声明一下类型实现了哪些接口。&lt;/p&gt;

&lt;p&gt;还是摘抄自&lt;a href=&#34;https://golang.org/doc/faq#Why_is_there_no_type_inheritance&#34;&gt;GO语言官方文档的FAQ&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Rather than requiring the programmer to declare ahead
of time that two types are related, in Go a type
automatically satisfies any interface that specifies a
subset of its methods.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通常，接口的定义都很短，甚至有可能至包含一个方法声明。在地道的GO语言实践中，你不应该看到一个接口拥有长长的方法列表。&lt;/p&gt;

&lt;p&gt;借助这样的接口就可以很优雅地实现&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%9E%8B_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)&#34;&gt;多态&lt;/a&gt;: 一个方法如果接受某一个接口，那么就意味着这个方法接受了任何实现了该接口的对象.&lt;/p&gt;

&lt;h3 id=&#34;方法&#34;&gt;方法&lt;/h3&gt;

&lt;p&gt;GO语言中的类型往往都拥有方法，但是这些方法的定义是独立于类型定义而存在的。GO语言在语法层面通过一个类似Javascript中prototype方法的特性来实现了这种定义的独立性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Person(first, last) {
    this.firstName = first;
    this.lastName = last;
}
Person.prototype.name = function() {
    return this.firstName + &amp;quot; &amp;quot; + this.lastName;
};
p = new Person(&amp;quot;Flavio&amp;quot;, &amp;quot;Copes&amp;quot;)
p.name() // Flavio Copes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在GO语言中，代码应该写成这样:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)
type Person struct {
	firstName string
	lastName  string
}
func (p Person) name() string {
	return p.firstName + &amp;quot; &amp;quot; + p.lastName
}
func main() {
	p := Person{&amp;quot;Flavio&amp;quot;, &amp;quot;Copes&amp;quot;}
	fmt.Println(p.name())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;关联方法与类型&#34;&gt;关联方法与类型&lt;/h3&gt;

&lt;p&gt;方法可以被关联至任何类型,甚至是&amp;rdquo;曲线救国&amp;rdquo;式地关联到GO语言中的基础类型。由于方法只能被关联至在同一个包中定义的类型,所以我们无法直接&amp;rdquo;扩展&amp;rdquo;基础类型。但事实上，我们可以通过对基础数据类型定义别名从而达到扩展的目的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

type Amount int

func (a *Amount) Add(add Amount) {
	*a += add
}

func main() {
	var a Amount
	a = 1
	a.Add(2)
	fmt.Println(a)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://play.golang.org/p/ONlUmue1jA&#34;&gt;显示结果&lt;/a&gt; (需要科学上网)&lt;/p&gt;

&lt;h3 id=&#34;函数&#34;&gt;函数&lt;/h3&gt;

&lt;p&gt;让我们回想一下传统的面向对象编程语言吧，比如Java。想想看你曾经定义过多少次包含的全是static方法的名为&amp;rdquo;Utils&amp;rdquo;的类?&lt;/p&gt;

&lt;p&gt;这样的现象来源与传统的面向对象变成语言中的一个观念: &lt;strong&gt;一切皆是对象&lt;/strong&gt;，因此函数定义必须放在一个类里面。所幸的是，这种现象不会发生在GO语言中，因为GO语言有真正的&amp;rdquo;函数&amp;rdquo;这一概念。在真实世界中，并非所有事物都必须是一个对象。&amp;rdquo;类&amp;rdquo;和&amp;rdquo;对象&amp;rdquo;的概念很有用，但也不能到处都用。&lt;/p&gt;

&lt;p&gt;在GO语言中，并非所有东西都是对象(若严格从技术角度而言，GO语言没有东西是对象。但通常人们会将一个类型的实例或者变量称之为&amp;rdquo;对象&amp;rdquo;),方法仅仅是指那些被关联至某一类型的函数。但GO语言同时又允许函数脱离于对象而独立存在,就如同C语言的函数一样。&lt;/p&gt;

&lt;p&gt;所以，GO语言既允许方法存在，也允许函数存在。而且，函数是第一优先的(函数类型可用作定义结构体字段,函数可作为参数传递至其他函数，函数也可作为返回值被函数或方法返回)。&lt;/p&gt;

&lt;h3 id=&#34;大道至简&#34;&gt;大道至简&lt;/h3&gt;

&lt;p&gt;综上所述，GO语言对于面向对象的实现非常灵活且直接。不用再纠结于类和继承，你可以减少对源码模板文件的依赖，而且不用再一点一点地推敲类与类之间的理想层级结构，从此你只需根据需求自由地对类型进行组合或拆解即可。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>主线程等待子线程结束的各语言实现</title>
      <link>https://xiaowing.github.io/post/20170805_main_thread_sync_with_others/</link>
      <pubDate>Sat, 05 Aug 2017 22:18:06 +0800</pubDate>
      
      <guid>https://xiaowing.github.io/post/20170805_main_thread_sync_with_others/</guid>
      <description>&lt;p&gt;在涉及到并发编程的情况下，经常性地会碰到一种场景:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;由一个线程开启了多个线程并发执行多个任务，之后由该线程(so called &amp;ldquo;主线程&amp;rdquo;)等待多个线程都结束后汇总结果.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这种场景下，主线程在其创建的子线程执行期间内需要阻塞，直到其他子线程都执行完毕。由于这类场景已经在不同语言的开发中遇到多次，所以汇总一下这些语言的常用实现方法，以后查起来也方便~&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;C语言实现
C语言在操作多线程方便由于缺乏一个统一的标准库，所以在Linux和Windows上各有各的实现方法:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Linux版实现&lt;/p&gt;

&lt;p&gt;在Linux上的实现，主要是基于POSIX thread库进行实现，实例代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;pthread.h&amp;gt;

int main(void) {
    int i;
    pthread_t threads[THREAD_NUM];

    pthread_setconcurrency(THREAD_NUM);

    for (i = 0; i &amp;lt; THREAD_NUM; i++){
        /* 将需要执行的job的函数地址func传入新建的子线程 */
        pthread_create(&amp;amp;threads[i], NULL, func, NULL);
    }

    for(i = 0; i &amp;lt; THREAD_NUM; i++){
        pthread_join(handles[i], NULL);
    }

    /* 后续的处理逻辑略... */
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Windows版实现&lt;/p&gt;

&lt;p&gt;在Windows版上的实现中，主要是基于Windows API实现。由于Windows本身就和Linux就是风格迥异，因此在阻塞主线程的API设计上，也是略有不同：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;Windows.h&amp;gt;

int main(void) {
    int i;
    HANDLE handles[THREAD_NUM];

    for (i = 0; i &amp;lt; THREAD_NUM; i++){
        /* 将需要执行的job的函数地址func传入新建的子线程 */
        handles[i] = CreateThread(NULL, 0, func, NULL, 0, NULL);
    }

    WaitForMultipleObjects(THREAD_NUM, handles, TRUE, INFINITE);

    /* 后续的处理逻辑略... */
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是，Windows API的&lt;code&gt;WaitForMultipleObjects()&lt;/code&gt;其实不仅仅是为多线程场景服务的，它可以用与多种内核句柄，如&lt;code&gt;Event&lt;/code&gt;，&lt;code&gt;Mutex&lt;/code&gt;，&lt;code&gt;Process&lt;/code&gt;，&lt;code&gt;Thread&lt;/code&gt;，&lt;code&gt;Semaphore&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Python3的实现&lt;/p&gt;

&lt;p&gt;Python3的实现形式与C语言的Linux版类似: 当子线程仍活着的时候，则通过类似Join()方法之类的API来阻塞当前的主线程。代码示例如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from threading import Thread

if __name__ == &#39;__main__&#39;:
    thread_list = []

    for x range (0, THREAD_NUM):
        # 将需要执行的job的函数和参数传入新建的子线程
        t = Thread(target=job_func, args=(job_args,))
        t.start()
        thread_list.append(t)
        
    for element in thread_list:
        if element.is_alive():
            element.join()    # 通过join方法阻塞主线程
    else:
        # 后续的处理逻辑略...
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Golang的实现&lt;/p&gt;

&lt;p&gt;由于Golang的语言特色，并发通过goroutine来实现。通常情况下，各个goroutine根本不需要知道彼此的存在。因此对于这个场景的实现方式，与之前的那些语言都有所不同.代码示例如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main
    
import (
    &amp;quot;sync&amp;quot;
)

func main() {
    var wait sync.WaitGroup
    wait.Add(ROUTINE_NUM)

    for i := 0; i &amp;lt; ROUTINE_NUM; i++ {
        go func() {
            defer wait.Done()

            //Goroutine所要执行的Job逻辑略...
        }()
    }
    wait.Wait()

    // 后续的处理逻辑略...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在之前的语言中，主线程在起了多个子线程后，不管用什么API阻塞，主线程或多或少还需要关注一下子线程(句柄等)，但是在Golang中，主协程不需要关注各个携程。主协程等待其他协程的这个场景，完全基于Workgroup就可以简单实现。&lt;/p&gt;

&lt;p&gt;真不愧是一门面向并发的语言:)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后需要说明的是，虽然本文描述的这个场景叫做&amp;rdquo;主线程等待子线程&amp;rdquo;。但实际上，无论是线程模型还是协程模型，线程与线程之间(协程与协程之间)都是平等的。毕竟只有在多进程模型下，被fork出的子进程会继承父进程的大部分数据(如打开的文件描述符)，完全相当于父进程的副本的形式。而这样的关系在线程模型(或协程模型)中并不存在，此处的说法完全只是遵循某种不成文的惯例，算是&amp;rdquo;&lt;strong&gt;阀值&lt;/strong&gt;&amp;ldquo;之于&amp;rdquo;&lt;strong&gt;阈值&lt;/strong&gt;&amp;ldquo;这样的错误吧。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C语言程序通过函数指针调用Go函数的方法</title>
      <link>https://xiaowing.github.io/post/howto_call_a_go_func_via_funcpoint_from_cside/</link>
      <pubDate>Sun, 30 Jul 2017 16:16:03 +0800</pubDate>
      
      <guid>https://xiaowing.github.io/post/howto_call_a_go_func_via_funcpoint_from_cside/</guid>
      <description>&lt;p&gt;在github上关于cgo的wiki中，有一&lt;a href=&#34;https://github.com/golang/go/wiki/cgo#function-pointer-callbacks&#34;&gt;章节&lt;/a&gt;专门介绍了如何利用cgo技术通过函数指针调用Golang的函数实现. 不过，仔细观察这个章节的代码示例可以发现，它所要解决的其实是以下的场景:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在Golang中想要调用一个已有的C语言函数，但是该C语言函数要求一个函数指针作为参数时应该怎么办？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果将这个场景稍微改变一下，改成以下场景，对应的解法又该是什么？&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在一个C语言实现的已有系统中，对于一个要求函数指针的函数，如何传入一个Golang实现的回调函数以实现“用Golang扩展C语言系统”的目的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我基于wiki中已有的代码简单探索了一下方法，结果分享如下：&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;试验代码的准备&#34;&gt;试验代码的准备&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先，需要一个声明了函数指针类型的头文件(也就是C语言和Golang的接口)。这里流用了上述wiki中的示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* clib.h */

#ifndef CLIBRARY_H
#define CLIBRARY_H
typedef int (*callback_fcn)(int);
#endif
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;接下来是C语言程序中调用上述函数指针的入口函数.这个文件也是从wiki中流用的.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* clib.c */
#include &amp;lt;stdio.h&amp;gt;
#include &amp;quot;clib.h&amp;quot;

void some_c_func(callback_fcn callback)
{
    int arg = 2;
    printf(&amp;quot;C.some_c_func(): calling callback with arg = %d\n&amp;quot;, arg);
    int response = callback(2);
    printf(&amp;quot;C.some_c_func(): callback responded with %d\n&amp;quot;, response);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个程序中，没有定义callback_fcn这个函数指针的具体实现。这个实现将交给下面的Golang进行&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在Golang中实现回调函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* goprog.go */
package main        /* 包名必须是main */

/*
#cgo CFLAGS: -I {clib.h的路径(目录)}

#include &amp;quot;clib.h&amp;quot;

int callOnMeGo_cgo(int in); // Forward declaration.
*/
import &amp;quot;C&amp;quot;

import &amp;quot;fmt&amp;quot;

//export callOnMeGo
func callOnMeGo(in int) int {
    fmt.Printf(&amp;quot;Go.callOnMeGo(): called with arg = %d\n&amp;quot;, in)
    return in + 1
}

func main() {}        /* 必须定义一个空的main函数 */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个文件基于Wiki中的示例稍微改了一点，把main函数的实现给去掉了，但保留了一个空的main函数。 此外，不论这个文件在哪里创建，它的package被定义为main。相关的理由如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;cgo在将go源代码编译成shared-library的过程中，只会将package声明为main的源代码纳入编译，其余的文件都会被忽略&lt;/li&gt;
&lt;li&gt;由于参与编译的源代码的package都为main，根据Golang编译器的规则，则必须有一个main()函数，否则编译不过&lt;/li&gt;
&lt;li&gt;根据第2点，如果参与编译的源码中有超过一个main函数，编译器也会报错。
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意: 这里有一个坑：如果将带main函数的.c文件和这些go文件放在一起，然后启动golang编译器编译器编译，也会报错，说main函数数量过多。不知golang编译器为什么要去识别C语言的main函数&amp;hellip;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;这样一来，回调函数的实现本体就已经完成了。但是如果仅仅如此，是无法实现C语言调用这个函数的，这是因为两种语言的类型不一致，因此实际上上述回调函数的接口与函数指针的声明仍然不一样，所以需要一个&lt;strong&gt;Adapter&lt;/strong&gt;。在cgo中，这样的&lt;strong&gt;Adapter&lt;/strong&gt;被称为&amp;rdquo;&lt;code&gt;Gateway Function&lt;/code&gt;&amp;rdquo;. 直接搬用Wiki中的代码即可：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* cfuncs.go */
package main

/*

#include &amp;lt;stdio.h&amp;gt;

// The gateway function
int callOnMeGo_cgo(int in)
{
    printf(&amp;quot;C.callOnMeGo_cgo(): called with arg = %d\n&amp;quot;, in);
    int callOnMeGo(int);
    return callOnMeGo(in);
}
*/
import &amp;quot;C&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有意思的是，这个Gateway Function实际上是一个实现在go源码注释中的C语言函数，它的声明与函数指针一致。但是它实际封装的却又是一个golang函数.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;构建过程&#34;&gt;构建过程&lt;/h2&gt;

&lt;p&gt;到这时为止，所需的代码就算是写完了，接下来需要把程序构建并运行起来：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;用golang编译器构建共享库:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$go build -buildmode=c-shared -o libgoprog.so {所有参与编译的go源码}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;值得注意的是，&lt;code&gt;-buildmode=c-shared&lt;/code&gt; 是直到&lt;strong&gt;golang1.5&lt;/strong&gt;开始才有的选项，且该选项到目前为止(golang1.8)只支持linux平台，&lt;strong&gt;不支持windows和Mac OS&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;编译成功后，会生成两个文件： 一个是库文件(&lt;code&gt;libgoprog.so&lt;/code&gt;), 另一个是该库文件对应的头文件(&lt;code&gt;libgoprog.h&lt;/code&gt;).这个头文件的片段如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* libgoprog.h */

#include &amp;quot;clib.h&amp;quot;
int callOnMeGo_cgo(int in);  /* &amp;lt;- 在go源码中定义的Gateway Function */

...(中略)...

extern GoInt callOnMeGo(GoInt p0);   
...(下略)...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时如果用&lt;code&gt;file&lt;/code&gt;命令看一下生成的.so文件，应该是类似以下的结果：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;libgoprog.so: ELF 64-bit LSB  shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=f49bbe5d2d38c184574b65ed11f55e84c1ad19e3, not stripped&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;同时，如果用&lt;code&gt;nm&lt;/code&gt;查看这个.so文件的导出符号，就可以看到callOnMeGo和callOnMeGo_cgo这两个符号了&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;由于上一步骤生成了这个头文件，所以此处还需要修改一下之前的 clib.c 文件，把这个头文件给 #include 进去，从而就可在clib.c中看见那个Gateway Function的声明了，而且此时就可以为clib.c文件补上 main() 函数的实现了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* clib.c 完整版 */

#include &amp;lt;stdio.h&amp;gt;
#include &amp;quot;clib.h&amp;quot;
#include &amp;quot;libgoprog.h&amp;quot;    /* 追加头文件引用 */

void some_c_func(callback_fcn callback)
{
    int arg = 2;
    printf(&amp;quot;C.some_c_func(): calling callback with arg = %d\n&amp;quot;, arg);
    int response = callback(2);
    printf(&amp;quot;C.some_c_func(): callback responded with %d\n&amp;quot;, response);
}

int main(void) {        /* 追加main()函数实现 */
    some_c_func(callOnMeGo_cgo);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编译这个C程序&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;$gcc clib.c -I{clib.h的目录路径} -I{生成的libgoprog.h的目录路径} -L{libgoprog.so的目录路径} -lgoprog -o clibmain
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一切正常的话，就可以正常生成可执行文件clibmain了。之后再将先前生成的libgoprog.so 放置到链接器可找到的路径下，执行该程序就可得到下述结果了:&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;



&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;pure-u-1-1&#34;&gt;
    &lt;div style=&#34;padding: 0 .2em&#34;&gt;
      &lt;img
        class=&#34;pure-img-responsive&#34;
        src=&#34;https://xiaowing.github.io/img/post/c-calls-go-output.jpg&#34;
        alt=&#34;通过函数指针调用golang函数的输出&#34;&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;


&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;综上，使用golang自带的cgo技术，可以方便地打通C语言和Golang语言。但目前，Go语言编译动态库还只能在Linux平台上实现，需要注意。&lt;/p&gt;

&lt;p&gt;另外，考虑到两种语言在数据类型上还是存在较多差异(事实上，编译生成共享库时附带生成的头文件中就定义了大量golang类型到C语言的映射)，因此，如果真的要编写程序在C语言中调用Go，其实有相当一部分工作量应该会花在数据类型转换上。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>一件如故的Go语言</title>
      <link>https://xiaowing.github.io/post/why_i_love_the_go_programming_language/</link>
      <pubDate>Sun, 30 Jul 2017 14:17:37 +0800</pubDate>
      
      <guid>https://xiaowing.github.io/post/why_i_love_the_go_programming_language/</guid>
      <description>&lt;p&gt;从去年接触Go语言(以后简称&amp;rdquo;Golang&amp;rdquo;)到现在，已经有1年的时间了。感觉随着使用经验的积累，越发地喜爱这么编程语言。作为一个以C, C#语言出道，并自学了Java, Python, Golang的无证程序员，使用 了一段时间Go语言后，最明显的感觉就是：“这正式我所期盼的语言”。特别是写多了C语言代码，虽然感叹于C语言在语言上的简洁与性能上的高效，但是对于现实中C语言在开发方面的低效也总是吐槽不断。遭遇了Go语言之后，认为这门语言是C语言的最好传人(不要提C++)。&lt;/p&gt;



&lt;div class=&#34;pure-g&#34;&gt;

  
  
  
  
  &lt;div class=&#34;pure-u-1-1&#34;&gt;
    &lt;div style=&#34;padding: 0 .2em&#34;&gt;
      &lt;img
        class=&#34;pure-img-responsive&#34;
        src=&#34;https://xiaowing.github.io/img/post/golang-gopher-100.jpg&#34;
        alt=&#34;Gopher&#34;&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  

&lt;/div&gt;


&lt;p&gt;以下分享一些我认为Golang做的比较值得推崇的地方：&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Golang是直接编译成本地机器码，这就决定了其二进制是无法跨平台的。但是得益于Golang社区在各个平台上开发的编译器都很给力，而且提供了共通且强大的标准库，使得对于Go语言的开发者而言事实上不需要去太关注跨平台的问题(当然，可能会需要在特定平台上额外加一些分支代码以做优化或处理平台本身的差异)也能保证Golang程序拥有不弱于C的运行性能。这一点相比较C语言开发而言，实在时友善了太多：

&lt;ul&gt;
&lt;li&gt;C语言为了兼容不通平台，往往会用到条件编译，如果没有实现好好设计跨平台的问题，代码中就会充斥着一大堆#ifdef ，导致可读性极差；但如果每个C语言项目都要去专门为跨平台好好设计一番，却又会导致项目的额外投入以及关注点扩散。总之实际开发中的效率不会高&lt;/li&gt;
&lt;li&gt;C语言标准库功能太薄弱，所以各个平台往往为了相似的基础功能折腾出一堆不通的基础库。尽管后来有了Posix规范，但毕竟这只是个弱约束。比如说巨硬的WinAPI，完全看不到一点Posix的影子，你也不能拿它怎么样。所以还是导致C语言项目会专门为了跨平台投入过多的人力和成本。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Golang提供了一个内存管理机制(含GC)。这相对于原先的C语言开发而言，可算是大大地解放生产力了：

&lt;ul&gt;
&lt;li&gt;C语言开发需要自行管理内存的分配与释放(其实说法不确切，标准库的malloc函数群其实是实现了一个内存池以避免触发过多系统调用)，每一个C语言工程师肯定都与诸如内存泄露，重复释放，野指针误操作等问题搏斗过，费时费力。&lt;/li&gt;
&lt;li&gt;不少C语言开发项目的工作量都耗费在了为本项目进行的内存管理的设计与开发上了。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;得益于Golang自带内存管理功能，因此Golang提供了源生的string类型，而且颇为独特地将内置字符串的文字编码定义为UTF-8(Java，C#，Python3的内置字符串类型的文字编码都是UTF-16)。这样的设计带来了一些显而易见的好处:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;相较于C语言开发，用Golang开发时终于不用自己去处理 &lt;code&gt;char *&lt;/code&gt;指针了。我们学C语言，道行尚浅往往会有个错觉，以为字符串一定会以&amp;rsquo;\0&amp;rsquo;结尾。这个理解得不深刻，往往会给我们带来一些麻烦。之后被坑得多了，才终于反应过来——NM就是一个字节数组。这个积累过程往往需要一些时间，归根结底还是没有一个专门的字符串类型(但事实上，通常情况下，我们要处理的数据有大多数都是字符串)。所以Golang提供了一个string类型也是理所当然。Golang对于String的实现也很符合实际，就是一个形如下方的结构体。这也导致了为什么在Golang中对string进行遍历时是基于字节而非字符来遍历的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct String
{
    byte*   str;
    intgo   len;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;与Java，C#，Python不同的是，Golang的字符串类型的文字编码是UTF8。我个人认为这是考虑到了互联网的需求。毕竟UTF16的每一个字符要占用两个字节。而考虑实际的情况，不管你是传一个html，还是传一个json报文，终究大部分字符还是那些在标准ASCII码范围内的字符。而且，假设数据真的按UTF16来传，还会牵扯到Big-endian和Little-endian的问题。而按UTF8编码传递则没有此问题。可以说，选择UTF-16的话，只对于语言本身的实现时可以减轻不少负担。所幸，Golang的设计者们也认识到了这一点。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Golang中对于函数库的构建，都是统一编译为静态库。当调用者要使用时是要在编译阶段就将函数库静态链接进来的。这个特性有时不被开发者理解，甚至有人认为是一种倒退。但如果我们仔细梳理一下就会发现用静态库时经过深思熟虑的选择：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;部署方便，不会再存在Dependency Hell的问题（代价是程序加载时会多吃点内存）。Linux 系的程序经常陷入Dependency Hell的困扰；而Windows程序虽然稍微好一点，但它是因为在Windows系程序的最佳实践，通常时把所依赖的动态库一并发布。保证程序和程序之间井水不犯河水，以希图消除Dependency Hell的问题，但结果就是，把动态库(又称“共享库”)技术中的“共享”给丢了。&lt;/li&gt;
&lt;li&gt;另一方面，从程序开发技术的历史来看，静态链接技术的诞生是早于动态链接技术的。甚至应该说，动态链接技术更像是静态链接当年面对贫瘠的内存与磁盘资源所做出的一个妥协性质的进化。既然在21世纪的今天，连PC机的内存与磁盘都已经不再是问题的情况下，作为一门新语言，选择在技术上返朴归真也是情有可原。更何况，如果从纯性能角度考量，静态库是要优于动态库的。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Golang还是一门没有实现“类”这个概念但却仍旧可以让你进行面向对象编程的语言。这样一来，概念就非常清晰了，和当年C语言的“简约”的思想一脉相承：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;从80时代开始，“面向对象”思想就开始广为流传。它作为程序设计的一种方法论本身没有错，但问题是如果一个语言非要以支持不支持类这个概念来一刀切地区分自己是不是一个支持面向对象的语言。这就有点走火入魔了。在这方面，Java和C#是这类语言的极端代表，于是写一个入口函数main函数，都得先定义一个类，这实在是让人哭笑不得。更不用说Java和C#在后面的发展中被自己的“必须得有类”的这个概念所坑，先后都引入了一个称之为“静态类”的不伦不类的东西。万幸，Golang吸取了这个教训，没有搞出“类”这个东西。&lt;/li&gt;
&lt;li&gt;面向对象的思想其实是与语言无关，事实上，就算是用C语言也仍然可以在“面向对象”思想的主导下实施开发，从一些优秀开源代码(如PostgreSQL)来看，用C语言也照样可以写出面向对象的风格。与C语言类似，Golang对于“面向对象”思想的三个基本特征也是予以了一定的支持，实现了对“面向对象”技术的“取取其精华去其糟粕”：

&lt;ul&gt;
&lt;li&gt;封装 —— 通过golang的package机制的数据/函数公开规则予以实现&lt;/li&gt;
&lt;li&gt;继承 —— 通过Interface机制在思想上进行了实现（尽管Golang的接口时通过“组合”(Composite)来实现的），但是在语言特性层面却没有专门的“继承”功能&lt;/li&gt;
&lt;li&gt;多态 —— 语言特性上没有专门的“多态”，甚至连函数的参数化多态(Overloading)也不支持&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Golang保留了指针，有助于帮助开发者厘清数据之间关系的真实情况：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在函数参数方面，Java和C#算是捣糨糊的高手。Java为了所谓的“值传递”与“引用传递”，凭空捣鼓出了“原始类型”和“引用类型”这两个概念；C#则更进一步，在彻底地把所有类型都变成“类”了之后，捣鼓出了“值类型”和“引用类型”这两个概念。当然，正式因为这两个高级语言对开发者屏蔽了“地址”(也就是“指针”)这个概念后不得不生造出的概念。其实事情本可以很简单——只要一门语言中的函数调用的参数传递还是基于栈模型(有没有其他模型我不知道&amp;hellip;)，那么参数传递一定是把你希望传递的数据给拷贝走一份后再进行操作。因此，如果你想在一个函数中改变一个已有的数据结构实例中的属性（成员变量），那么你就老老实实地把这个实例的地址(指针)给传过去。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Golang通过&amp;rdquo;接受者&amp;rdquo;(receiver)这个概念，可以把一个函数变成某个数据类型的“方法”，从而相较于C语言的代码更易理解，易维护：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;正如“类”不是必须的，“方法”其实也不是必须的。receiver这个特性更像是一个语法糖。只是，有了方法之后从代码层面就可以更明显地看出一个操作和一个数据结构之间时强联系还是弱联系。也正因为有了这个特性，所以Golang的“面向对象”的特征就“更加明显”了。&lt;/li&gt;
&lt;li&gt;写C语言代码时，通常为了在代码中体现一个函数与一个数据结构是强联系，函数是数据结构的“方法”，所以通常会选择把这个数据结构的参数放在函数参数列表的第一个。也许Golang设计团队对于这个最佳实践也是深有感触之后才下决心做了“receiver”这个特性。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Golang中的&lt;code&gt;defer&lt;/code&gt;机制可以有效增强代码的健壮性。用其他语言写代码，一旦涉及到数据库连接，文件句柄等资源操作时要格外小心，生怕有什么分支忘记关闭这些资源。有了defer机制，打可以在打开资源语句的下一条语句就用defer把关闭资源的操作塞入栈中，确保关闭操作一定被执行。并且有效地减少了函数中各种退出分支中冗长的关闭资源代码。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;至于Golang语言中以go关键字和chan关键字体现出的 “协程”和 “信道”这两个并发程序开发中的利器，已经有太多人盛赞过了，这里就不在赘述。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;从以上可以看出，其实Golang语言的一些特性是源于C语言，但又更好地解决了C语言开发中的一些通点，使得在不太牺牲性能的前提下提升开发效率。Golang团队不愧是有C语言的发明者之一的Ken Tompson参与，所以能够有的放矢地去改善C语言在新时代形势下的一些课题。&lt;/p&gt;

&lt;p&gt;然而，Golang中终究还是有一些我个人觉得比较遗憾的地方，也记录在此吧:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;以 &lt;code&gt;${变量名} 类型&lt;/code&gt; 这样类型在后的声明方式终究还是太小众了，特别是有时候定义函数时，写着写着就把参数列表写成了 类型 ${参数名} 这样的传统方式了。然后非要等编译出错才能反应过来(有时候还未必能反应过来)。 类型在后的声明方式，想了半天似乎也就只有&lt;strong&gt;SQL&lt;/strong&gt;是这样的。&lt;/li&gt;
&lt;li&gt;与C语言一样，Golang中无法定义参数类型不同，函数名与返回值类型相同的 所谓&lt;a href=&#34;https://en.wikipedia.org/wiki/Function_overloading&#34;&gt;Function Overloading&lt;/a&gt;。因此一个功能相同仅仅是为了处理不同参数类型的一组函数，非得费破脑细胞取给各个函数想名字，这也是很无奈的。&lt;/li&gt;
&lt;li&gt;Golang因为是 强类型 &amp;amp; 静态类型 的关系(C语言是 弱类型 &amp;amp; 静态类型)，很多在C语言，Java, C#中都可以隐式类型转换的写法在C语言中必须得做显式类型转换，代码就难免会多起来。感觉语言设计者想通过这种方式来甩锅啊&amp;hellip;&amp;hellip;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;不过，瑕不掩瑜。Golang还是一门非常值得学习的语言。2015年末我自学了Python，本来想好好研究一下Python的。结果一接触Golang之后，就立刻爱不释手，我想大概还是因为我是从C语言这一路学习过来的吧。所以我建议所有有C语言开发经验的人都取接触一下Golang，也许就会和我一样有“相见恨晚”的感觉。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>